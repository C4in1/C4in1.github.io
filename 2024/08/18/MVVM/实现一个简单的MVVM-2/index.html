<!DOCTYPE html>
<html 
	lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> 实现一个简单的MVVM-2 -  C4iN&#39;s Caprice</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="https://pic.imgdb.cn/item/6693875ad9c307b7e98b4288.gif"
			type="image/gif"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('https://pic.imgdb.cn/item/66b458ffd9c307b7e9aadb03.png')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="C4iN&#39;s Caprice">
        <img
			src="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png"
			alt="破酥 | C4iN"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png" title="破酥 | C4iN">
			<img
				src="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png"
				alt="破酥 | C4iN"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>11</div>
		<div><span>标签</span>13</div>
		<div><span>分类</span>6</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/friends"
			title="我的朋友"
		>
			<i
				class="kirafont
					
						icon-team
					"
			></i>
			<div class="kira-list-item-content">
				我的朋友
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2405544030&website=www.oicqzone.com"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/CainHappyfish/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/MVVM/">
              MVVM
            </a>
            <span class="category-list-count">3</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/TypeScript/">
              TypeScript
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/Vue/">
              Vue
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/project/">
              project
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/vitepress/">
              vitepress
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/项目构建/">
              项目构建
            </a>
            <span class="category-list-count">2</span>
          </li>
        
      </ul>
    </div>
  </div>

		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/MVVM/" style="font-size: 14px;">MVVM</a> <a href="/tags/TypeScript/" style="font-size: 18px;">TypeScript</a> <a href="/tags/Typescript/" style="font-size: 10px;">Typescript</a> <a href="/tags/Vitepress/" style="font-size: 12px;">Vitepress</a> <a href="/tags/Vue/" style="font-size: 14px;">Vue</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/theme-censored/" style="font-size: 12px;">theme-censored</a> <a href="/tags/vue3/" style="font-size: 16px;">vue3</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E7%97%9B%E8%8B%A6%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" style="font-size: 12px;">痛苦的配置问题</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83/" style="font-size: 10px;">项目规范</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			Archive
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">11</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2024
		<a href="/">破酥 | C4iN</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><div><span id="busuanzi_container_site_uv">共接待访客<span id="busuanzi_value_site_uv"></span>位</span></div>
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div class="kira-post-cover">
			<img
				data-src="https://pic.imgdb.cn/item/66b47385d9c307b7e9d0b377.png"
				data-sizes="auto"
				alt="实现一个简单的MVVM-2"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>实现一个简单的MVVM-2</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2024年08月18日</a>
			<a><i class="kirafont icon-edit-fill"></i>6.3k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 29 分钟</a>
		</div>
		<p>这部分我们来介绍MVVM系统的渲染器部分。</p>
<span id="more"></span>

<p>渲染器是用来执行渲染任务的。在浏览器平台上，用它来渲染其中的真实 DOM 元素。渲染器不仅能够渲染真实 DOM 元素，它还是框架跨平台能力的关键。因此，在设计渲染器的时候一定要考虑好可自定义的能力。我们利用响应系统的能力，自动调用渲染器完成页面的渲染和更新，这个过程与渲染器的具体实现无关，仅仅设置了元素的<code>innerHTML</code>内容。</p>
<p><del>玩黑神话中</del></p>
<h1><span id="基本概念">基本概念</span></h1><ul>
<li>渲染器<code>renderer</code>（注意render表示渲染这一动词）：渲染器的作用是把虚拟 DOM 渲染为特定平台上的真实元素。在浏览器平台上，渲染器会把虚拟 DOM 渲染为真实 DOM 元素。</li>
<li>虚拟DOM &amp; 虚拟节点<code>vnode</code>：虚拟 DOM 和真实 DOM 的结构一样，都是由一个个虚拟节点组成的树型结构。</li>
<li>挂载<code>mount</code>：渲染器把虚拟 DOM 节点渲染为真实 DOM 节点的过程叫作挂载。</li>
<li>容器<code>container</code>：渲染器通常需要接收一个挂载点作为参数，用来指定具体的挂载位置。这里的“挂载点”其实就是一个DOM 元素，渲染器会把该 DOM 元素作为容器元素，并把内容渲染到其中，称为容器。</li>
</ul>
<p>描述上述概念之间关系的代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRenderer</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>        ...<br>    &#125;<br>        <br>    <span class="hljs-keyword">return</span> render<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>createRenderer</code>函数用来创建一个<strong>渲染器</strong>。调用<code>createRenderer</code>函数会得到一个 render 函数，该<code>render</code>函数会以<code>container</code>为挂载点，将<code>vnode</code>渲染为真实 DOM并添加到该挂载点下。渲染器不仅包含<code>render</code>函数，还包含<code>hydrate</code>函数等。关于<code>hydrate</code>函数，介绍服务端渲染时会详细讲解。在 Vue.js 3 中，创建应用的<code>createApp</code>函数也是渲染器的一部分。</p>
<p>接下里我们可以调用<code>createRenderer</code>函数创建一个渲染器，接着调用渲染器的<code>renderer.render</code>函数执行渲染。当多次在同一个<code>container</code>上调用<code>renderer.render</code>函数进行渲染时，渲染器除了要执行挂载动作外，还要执行更新动作。</p>
<p>首次渲染时已经把<code>oldVNode</code>渲染到<code>container</code>内了，所以当再次调用<code>renderer.render</code>函数并尝试渲染<code>newVNode</code>时，就不能简单地执行挂载动作了。在这种情况下，渲染器会使用<code>newVNode</code>与上一次渲染的<code>oldVNode</code>进行比较，试图找到并更新变更点。这个过程叫作“打补丁”（或更新，patch），下面是<code>render</code>函数的基本实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRenderer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (vnode) &#123;<br>      <span class="hljs-comment">// 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数</span><br>      <span class="hljs-title function_">patch</span>(container.<span class="hljs-property">_vnode</span>, vnode, container)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (container.<span class="hljs-property">_vnode</span>) &#123;<br>        <span class="hljs-comment">// 旧 vnode 存在，且新 vnode 不存在，说明是卸载（unmount）操作</span><br>        <span class="hljs-comment">// 只需要将 container 内的 DOM 清空即可</span><br>        container.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;<br><br>    container.<span class="hljs-property">_vnode</span> = vnode<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> render<br>&#125;<br></code></pre></td></tr></table></figure>

<p>渲染过程：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>()<br><br><span class="hljs-comment">// 首次</span><br>renderer.<span class="hljs-title function_">render</span>(vnode1, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>))<br><span class="hljs-comment">// 第二次</span><br>renderer.<span class="hljs-title function_">render</span>(vnode2, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>))<br><span class="hljs-comment">// 第三次</span><br>renderer.<span class="hljs-title function_">render</span>(<span class="hljs-literal">null</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>))<br></code></pre></td></tr></table></figure>

<ul>
<li>首次渲染：渲染器会将<code>vnode1</code>渲染为真实 DOM。渲染完成后，<code>vnode1</code>会存储到容器元素的<code>container._vnode</code>属性中，它会在后续渲染中作为旧<code>vnode</code>使用。</li>
<li>第二次渲染：旧<code>vnode</code>存在，此时渲染器会把<code>vnode2</code>作为新<code> vnode</code>，并将新旧<code>vnode</code>一同传递给<code>patch</code>函数进行打补丁。</li>
<li>第三次渲染：新<code>vnode</code>的值为<code> null</code>，即什么都不渲染。但此时容器中渲染的是<code>vnode2</code>所描述的内容，所以渲染器需要清空容器。从上面的代码中可以看出，我们使用<code>container.innerHTML = &#39;&#39;</code>来清空容器。需要注意的是，这样清空容器是有问题的，不过这里我们暂时使用它来达到目的。</li>
</ul>
<p><code>patch</code>函数是整个渲染器的核心入口，它承载了最重要的渲染逻辑。</p>
<ul>
<li>第一个参数：旧<code> vnode</code>。</li>
<li>第二个参数：新<code> vnode</code>。</li>
<li>第三个参数<code> container</code>：容器。</li>
</ul>
<p>在首次渲染时由于容器元素<code>_vnode</code>不存在，传递给 patch 函数的第一个参数<code>n1</code>是<code> undefined</code>。这时，<code>patch</code>函数会执行挂载动作，它会忽略<code> n1</code>，并直接将<code>n2</code>所描述的内容渲染到容器中。从这一点可以看出，<code>patch </code>函数不仅可以用来完成打补丁，也可以用来执行挂载。</p>
<h1><span id="自定义渲染器">自定义渲染器</span></h1><p>我们将以浏览器作为渲染的目标平台，编写一个渲染器。</p>
<p>我们用下面的数据结果定义<code>VNode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VNode</span> &#123;<br><br>  <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 用于存放vnode的特性和属性</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">props</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">symbol</span> | <span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;<br>  <span class="hljs-attr">children</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">VNode</span>&gt;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * DOM属性，可以是HTML元素容器，文本节点以及注释</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span> | <span class="hljs-title class_">Text</span> | <span class="hljs-title class_">Comment</span><br>  <span class="hljs-comment">// 唯一标识</span><br>  <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">symbol</span> | <span class="hljs-literal">undefined</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们实现<code>patch</code>函数，结构如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params"><span class="hljs-attr">oldNode</span>: <span class="hljs-title class_">VNode</span> | <span class="hljs-literal">undefined</span>, <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-comment">// 如果不存在旧虚拟节点，则需要挂载，调用mountElement</span><br>  <span class="hljs-keyword">if</span> (oldNode) &#123;<br>    <span class="hljs-title function_">mountElement</span>(newNode, container)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 存在旧虚拟节点，更新</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先来看<code>mountElement</code>是如何挂载的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-comment">// 创建HTML元素</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">type</span>)<br>  <br>  <span class="hljs-comment">// 挂载</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">/* 如果子节点是字符串，则说明是文本节点 */</span><br>    el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">children</span><br>  &#125; <br><br>  <span class="hljs-comment">// 将元素添加到挂载点下</span><br>  container.<span class="hljs-title function_">appendChild</span>(el)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先调用<code>document.createElement</code>函数，以<code>vnode.type</code>的值作为标签名称创建新的 DOM 元素。接着处理<code>vnode.children</code>，如果它的值是字符串类型，则代表该元素具有文本子节点，这时只需要设置元素的<code>textContent</code>即可。最后调用<code>appendChild</code>函数将新创建的<code>DOM</code>元素添加到容器元素内。这样，我们就完成了一个<code>vnode</code>的挂载。</p>
<p>我们的目标是设计一个不依赖于浏览器平台的通用渲染器，因此我们需要将浏览器特有的 API 抽离。我们把用于操作 DOM 的 API 封装为一个对象，并把它传递给<code>createRenderer</code>函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>(&#123;<br>    <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag)<br>    &#125;,<br>    <span class="hljs-title function_">setElementTest</span>(<span class="hljs-params">el, text</span>) &#123;<br>        el.<span class="hljs-property">textContent</span> = text<br>    &#125;,<br>    <span class="hljs-title function_">insert</span>(<span class="hljs-params">el, parent, anchor = <span class="hljs-literal">null</span></span>) &#123;<br>        parent.<span class="hljs-title function_">insertBefore</span>(el, anchor)<br>    &#125;<br>&#125;)<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRenderer</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;<br>        createElement,<br>        insert,<br>        setElementText<br>    &#125; = options<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们就可以从配置项中直接读取对应的API。</p>
<h1><span id="挂载和更新">挂载和更新</span></h1><h2><span id="子节点">子节点</span></h2><p>一个元素除了具有文本子节点外，还可以包含其他元素子节点，并且子节点可以是很多个。当<code>vnode</code>含有标签属性<code>props</code>时，我们需要将这些属性渲染到真实DOM中。<code>HTML</code>标签有很多属性，其中有些属性是通用的，例如 id、class 等，而有些属性是特定元素才有的，例如<code>form</code>元素的<code>action</code>属性。修改<code>mountElement</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-comment">// 创建HTML元素</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">type</span>)<br><br>  <span class="hljs-comment">// 遍历props，将属性、事件添加到元素</span><br>  <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) &#123;<br>      <span class="hljs-comment">/* 添加props到元素的属性、事件中 */</span><br>      <span class="hljs-title function_">patchProps</span>(vnode, container, key)<br>    &#125;<br><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">/* 如果子节点是字符串，则说明是文本节点*/</span><br>    el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">children</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(vnode.<span class="hljs-property">children</span>)) &#123;<br>    <span class="hljs-comment">/* 如果子节点是数组，则递归调用mountElement，遍历所有子节点 */</span><br>    vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> <span class="hljs-title function_">mountElement</span>(child, el))<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Wrong Type&quot;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 将元素添加到挂载点下</span><br>  container.<span class="hljs-title function_">appendChild</span>(el)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>patchProps</code>用于挂载和更新 DOM 属性信息，我们针对不同的属性，逐步实现<code>patchProps</code>。在开始之前，我们先回顾一下<code>HTML Attrs</code>和<code>DOM Props</code>。</p>
<h2><span id="元素属性">元素属性</span></h2><p><code>HTML Attributes</code>指的就是定义在 HTML 标签上的属性。当浏览器解析 HTML 代码后，会创建一个与之相符的 DOM 元素对象，我怕们可以用JS代码获取该 DOM 对象。这个 DOM 对象会包含很多属性（properties），这些属性就是所谓的 DOM Properties。很多<code>HTML Attributes</code>在 DOM 对象上有与之同名的<code> DOM Properties</code>，但两者除了名字不总相同外，并不是所有<code>HTML Attrs</code>都有对应的<code>DOM props</code>。类似地，也不是所有<code>DOM Properties</code>都有与之对应的<code> HTML Attributes</code>。</p>
<p>不是所有<code>HTML Attributes</code>与<code>DOM Properties</code>之间都是像<code>id</code>那样直接映射的关系。实际上，<code>HTML Attributes </code>的作用是设置与之对应的<code>DOM Properties</code>的<strong>初始值</strong>。一旦值改变，那么<code>DOM Properties</code>始终存储着当前值，而通过<code>getAttribute</code>函数得到的仍然是初始值。一个<code>HTML Attributes</code>可能关联多个<code> DOM Properties</code>。</p>
<p>我们只需要记住一个核心原则即可：<code>HTML Attributes</code>的作用是设置与之对应的<code>DOM Properties</code>的初始值。</p>
<p>无论是使用<code>setAttribute</code>函数，还是直接设置元素的<code> DOM Properties</code>，都存在缺陷。要彻底解决这个问题，我们只能做特殊处理，即优先设置元素的<code> DOM Properties</code>，但当值为空字符串时，要手动将值矫正为<code> true</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">patchProps</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>:<span class="hljs-title class_">VNode</span>, <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span>, <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// 判断是否存在对应的DOM props</span><br>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> el) &#123;<br>    <span class="hljs-comment">// 获取HTML Attrs值</span><br>    <span class="hljs-keyword">const</span> attributeValue = el.<span class="hljs-title function_">getAttribute</span>(key)<br>    <span class="hljs-comment">// 获取props值</span><br>    <span class="hljs-keyword">const</span> propValue = vnode.<span class="hljs-property">props</span>[key]<br>    <span class="hljs-comment">// 如果是布尔类型，并且 value 是空字符串，则将值矫正为 true, 如disabled</span><br>    <span class="hljs-keyword">if</span> (attributeValue === <span class="hljs-string">&quot;&quot;</span> || propValue === <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      el.<span class="hljs-title function_">setAttribute</span>(key, <span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      el.<span class="hljs-title function_">setAttribute</span>(key, propValue)<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们需要把属性的设置也变成与平台无关，因此需要把属性设置相关操作也提取到渲染器选项中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>(&#123;<br>    <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag)<br>    &#125;,<br>    <span class="hljs-title function_">setElementTest</span>(<span class="hljs-params">el, text</span>) &#123;<br>        el.<span class="hljs-property">textContent</span> = text<br>    &#125;,<br>    <span class="hljs-title function_">insert</span>(<span class="hljs-params">el, parent, anchor = <span class="hljs-literal">null</span></span>) &#123;<br>        parent.<span class="hljs-title function_">insertBefore</span>(el, anchor)<br>    &#125;,<br>    <span class="hljs-title function_">patchProps</span>(<span class="hljs-params">el, key, prevValue, nextValue</span>) &#123;<br>        ...<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2><span id="class"><code>class</code></span></h2><p>Vue中为元素设置<code>class</code>有很多种方法：</p>
<ul>
<li><p><code>class=&quot;class1 class2&quot;</code>，指定 class 为一个字符串值</p>
<p>对应<code>vnode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>    <span class="hljs-attr">props</span>: &#123;<br>    	<span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;class1 class2&#x27;</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>:class=&quot;class1&quot;</code>，指定 class 为一个对象</p>
<p>对应<code>vnode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> class1 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span> &#125;<br><br><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>    <span class="hljs-attr">props</span>: &#123;<br>    	<span class="hljs-attr">class</span>: &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span> &#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>:class=&quot;arr&quot;</code>，指定 class 为一个数组</p>
<p>对应<code>vnode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">class</span> = [<br>    <span class="hljs-string">&#x27;class1&#x27;</span>,<br>    &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span> &#125;<br>]<br><br><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>    <span class="hljs-attr">props</span>: &#123;<br>    	<span class="hljs-attr">class</span>: [<br>            <span class="hljs-string">&#x27;class1&#x27;</span>,<br>            &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span> &#125;<br>        ]<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>因为 class 的值可以是多种类型，所以我们必须在设置元素的 class 之前将值归一化为统一的字符串形式，再把该字符串作为元素的 class 值去设置。我们简单实现<code>normalizeClass</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">normalizeClass</span>(<span class="hljs-params">classSeries</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">className</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = []<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> classSeries == <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> classSeries<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> classSeries === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; !<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(classSeries)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">normalizeObject</span>(classSeries)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(classSeries)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">normalizeArray</span>(classSeries)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;class type should be string, object or array.&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 标准化对象</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">normalizeObject</span>(<span class="hljs-params"><span class="hljs-attr">classSeries</span>: &#123;[index: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>]: <span class="hljs-built_in">boolean</span>&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">objectString</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = []<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(classSeries).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> classSeries[key] !== <span class="hljs-string">&#x27;boolean&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`class value <span class="hljs-subst">$&#123;<span class="hljs-built_in">String</span>(key)&#125;</span> must be a boolean.`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (classSeries[key]) &#123;<br>        objectString.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">String</span>(key))<br>      &#125;<br><br>    &#125;)<br>    <span class="hljs-keyword">return</span> objectString.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 标准化数组</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">normalizeArray</span>(<span class="hljs-params"><span class="hljs-attr">classSeries</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;</span>) &#123;<br>    classSeries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">item</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        className.<span class="hljs-title function_">push</span>(item)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">normalizeObject</span>(item)) &#123;<br>          className.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">normalizeObject</span>(item))<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`class value <span class="hljs-subst">$&#123;item&#125;</span> must be a string or object.`</span>)<br>      &#125;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, className)<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> className.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>)<br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们知道，在浏览器中为一个元素设置 class 有三种方式，即使用<code>setAttribute</code>、<code>el.className</code>或<code>el.classList</code>。其中<code>el.className</code>的性能最优。在<code>patchProps</code>添加对应逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (attributeValue === <span class="hljs-string">&quot;&quot;</span> || propValue === <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      el.<span class="hljs-title function_">setAttribute</span>(key, <span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>))<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;class&#x27;</span>) &#123;<br>      el.<span class="hljs-property">className</span> = vnode.<span class="hljs-property">props</span>[key]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      el.<span class="hljs-title function_">setAttribute</span>(key, propValue)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了 class 属性之外，我们也需要对<code>style</code>做类似的处理，不同的是不需要在<code>patchProps</code>添加对应逻辑处理style，这里就不做过多叙述。</p>
<h2><span id="卸载">卸载</span></h2><p>卸载操作发生在更新阶段，更新指的是，在初次挂载完成之后，后续渲染会触发更新。首次挂载完成后，后续渲染时如果传递了 null 作为新<code> vnode</code>，则意味着什么都不渲染，这时我们需要卸载之前渲染的内容。</p>
<p>回顾之前的<code>render</code>函数，我们直接通过<code>innerHTML</code>清空容器，这么做是不严谨的：</p>
<ul>
<li>容器的内容可能是由某个或多个组件渲染的，当卸载操作发生时，应该正确地调用这些组件的<code> beforeUnmount</code>、<code>unmounted</code>等生命周期函数。</li>
<li>即使内容不是由组件渲染的，有的元素存在自定义指令，我们应该在卸载操作发生时正确执行对应的指令钩子函数。</li>
<li>使用<code>innerHTML</code>清空容器元素内容的另一个缺陷是，它不会移除绑定在 DOM 元素上的事件处理函数。</li>
</ul>
<p>正确的卸载方式是，根据<code>vnode</code>对象获取与其相关联的真实 DOM 元素，然后使用原生 DOM 操作方法将该 DOM 元素移除。为此，我们需要在<code>vnode</code>与真实 DOM 元素之间建立联系，修改<code>mountElement</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 创建HTML元素，建立vnode与DOM之间的联系</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span> = vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">type</span>)<br></code></pre></td></tr></table></figure>

<p>当卸载操作发生的时候，只需要根据虚拟节点对象<code>vnode.el</code>取得真实 DOM 元素，再将其从父元素中移除：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> parent = vnode.<span class="hljs-property">el</span>.<span class="hljs-property">parentNode</span><br>    <span class="hljs-keyword">if</span> (parent) parent.<span class="hljs-title function_">removeChild</span>(vnode.<span class="hljs-property">el</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>unmount</code>函数内，我们有机会调用绑定在 DOM 元素上的指令钩子函数，例如<code> beforeUnmount</code>、<code>unmounted</code>等。当<code>unmount</code>函数执行时，我们有机会检测虚拟节点<code>vnode</code>的类型。如果该虚拟节点描述的是组件，则我们有机会调用组件相关的生命周期函数。</p>
<h2><span id="区分vnode">区分<code>vnode</code></span></h2><p>如果修改前后<code>vnode.type</code>属性的值不同，会造成新旧<code>vnode</code>所描述的内容不同，对于不同的元素来说，每个元素都有特有的属性。在这种情况下，正确的更新操作是，先将原元素卸载，再将新元素挂载到容器中。修改<code>patch</code>函数代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldNode, newNode, container</span>) &#123;<br>  <span class="hljs-comment">// 如果旧节点存在，则对比新旧节点的type</span><br>  <span class="hljs-keyword">if</span> (oldNode &amp;&amp; oldNode.<span class="hljs-property">type</span> !== newNode.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-comment">// 类型不同则卸载</span><br>    <span class="hljs-title function_">unmount</span>(oldNode)<br>    oldNode = <span class="hljs-literal">undefined</span><br>  &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>即使新旧<code>vnode</code>描述的内容相同，我们仍然需要进一步确认它们的类型是否相同。我们知道，一个<code>vnode</code>可以用来描述普通标签，也可以用来描述组件，还可以用来描述<code>Fragment</code>等。对于不同类型的<code>vnode</code>，我们需要提供不同的挂载或打补丁的处理方式。所以，我们需要继续修改<code>patch</code>函数的代码以满足需求：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// type是string类型，是普通元素</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果不存在旧虚拟节点，则需要挂载，调用mountElement</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-title function_">mountElement</span>(newNode, container)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 存在旧虚拟节点，更新</span><br>      <span class="hljs-title function_">patchElement</span>(oldNode, newNode)<br><br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-comment">// type是object类型，是组件</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="事件处理">事件处理</span></h2><p>事件可以视作一种特殊的属性，因此我们可以约定，在<code>vnode.props</code>对象中，凡是以字符串<code>on</code>开头的属性都视作事件。将事件添加到 DOM 元素上只需要在<code>patchProps</code>中调用<code> addEventListener</code>函数来绑定事件即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">...<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^on/</span>.<span class="hljs-title function_">test</span>(key)) &#123;<br>  <span class="hljs-keyword">const</span> event = key.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>()<br>  <span class="hljs-comment">// const invokers = el._invokers || (el._invokers = &#123;&#125;)</span><br>  <span class="hljs-comment">// let invoker: Invoker = invokers[event]</span><br>  el.<span class="hljs-title function_">addEventListener</span>(event, <span class="hljs-function">() =&gt;</span> &#123;<br>    vnode.<span class="hljs-property">props</span>[key]()<br>  &#125;)<br>&#125; <br><br>...<br></code></pre></td></tr></table></figure>

<p>当事件更新时，我们绑定一个伪造的事件处理函数<code>invoker</code>，然后把真正的事件处理函数设置为<code> invoker.value</code>属性的值。这样当更新事件的时候，我们将不再需要调用<code>removeEventListener</code>函数来移除上一次绑定的事件，只需要更新<code>invoker.value</code>的值。我们还需要在同一个时刻缓存多个事件处理函数，所以我们需要用一个对象来存储所有的事件处理函数，否则将会出现事件覆盖的现象。这个对象的键值是事件名称，而值则是对应的事件处理函数。而对于同一事件的不同处理函数，我们用数组来存取：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* 事件处理 */</span><br><span class="hljs-keyword">const</span> eventName = key.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>()<br><span class="hljs-comment">// 获取所有事件处理函数，如果不存在则新建一个</span><br><span class="hljs-keyword">const</span> invokers = el.<span class="hljs-property">_invokers</span> || (el.<span class="hljs-property">_invokers</span> = &#123;&#125;)<br><span class="hljs-keyword">let</span> <span class="hljs-attr">invoker</span>: <span class="hljs-title class_">Invoker</span> = invokers[eventName]<br><br><span class="hljs-keyword">if</span>(newVal) &#123;<br><span class="hljs-comment">/* 如果invoker不存在，则初始化 */</span><br><span class="hljs-keyword">if</span> (!invoker) &#123;<br>  <span class="hljs-comment">// 将事件处理函数缓存到el._invokers</span><br>  invoker = el.<span class="hljs-property">_invokers</span>[eventName] = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">Event</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(invoker.<span class="hljs-property">value</span>)) &#123;<br>      <span class="hljs-comment">// 如果 invoker.value 是数组，则遍历它并逐个调用事件处理函数</span><br>      invoker.<span class="hljs-property">value</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(event))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则直接调用</span><br>      <span class="hljs-keyword">if</span> (invoker.<span class="hljs-property">value</span>) &#123;<br>        invoker.<span class="hljs-title function_">value</span>(event)<br>      &#125;<br>    &#125;<br>  &#125;<br>  invoker.<span class="hljs-property">value</span> = newVal<br>  el.<span class="hljs-title function_">addEventListener</span>(eventName, invoker)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 有invoker直接更新</span><br>  invoker.<span class="hljs-property">value</span> = newVal<br>&#125;<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (invoker) &#123;<br>  <span class="hljs-comment">/* 如果没有新的事件绑定函数，移除原有事件监听 */</span><br>  el.<span class="hljs-title function_">removeEventListener</span>(eventName, invoker)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3><span id="事件冒泡与更新时机">事件冒泡与更新时机</span></h3><p>我们来看一个小例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> bol = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> vnode = &#123;<br>        <span class="hljs-keyword">type</span> = <span class="hljs-string">&#x27;div&#x27;</span>,<br>        <span class="hljs-attr">props</span>: bol.<span class="hljs-property">value</span> ? &#123;<br>            <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;parent clicked&quot;</span>)<br>            &#125;<br>    	&#125; : &#123;&#125;,<br>    	<br>    	<span class="hljs-attr">children</span>: [&#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>            <span class="hljs-attr">props</span>: &#123;<br>                <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>                    bol.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;,<br>            <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;text&quot;</span><br>        &#125;],          <br>    &#125;<br>    <br>    <span class="hljs-comment">// 渲染</span><br>    renderer.<span class="hljs-title function_">render</span>(vnode, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#app&quot;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>运行上面这段代码并点击<code>p</code>元素时，会发现父级<code>div</code>元素的<code>click</code>事件的事件处理函数竟然执行了，这其实与更新机制有关。</p>
<p>当点击 p 元素时，绑定到它身上的 click 事件处理函数会执行，于是<code>bol.value</code>的值被改为<code> true</code>。接下来的一步非常关键，由于<code>bol</code>是一个响应式数据，所以当它的值发生变化时，会触发副作用函数重新执行。由于此时的<code>bol.value</code>已经变成了<code> true</code>，所以在更新阶段，渲染器会为父级<code>div</code>元素绑定<code>click</code>事件处理函数。当更新完成之后，点击事件才从<code>p</code>元素冒泡到父级<code>div</code>元素。由于此时<code>div</code>元素已经绑定了<code>click</code>事件的处理函数，因此就发生了上述现象。</p>
<p>之所以会出现上述奇怪的现象，是因为更新操作发生在事件冒泡之前，即为 div 元素绑定事件处理函数发生在事件冒泡之前。</p>
<p><img src="https://pic.imgdb.cn/item/66c710cdd9c307b7e9d42aec.png"></p>
<p>事件触发的时间要早于事件处理函数被绑定的时间。这意味着当一个事件触发时，目标元素上还没有绑定相关的事件处理函数，我们可以根据这个特点来解决问题：<strong>屏蔽所有绑定时间晚于事件触发时间的事件处理函数的执行</strong>。</p>
<p>我们为<code>invoker</code>增加一个事件处理函数绑定时间<code>attachTime</code>，如果绑定时间晚于事件发生时间，则不执行事件处理函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (!invoker) &#123;<br>      <span class="hljs-comment">// 将事件处理函数缓存到el._invokers</span><br>      invoker = el.<span class="hljs-property">_invokers</span>[eventName] = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">Event</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// timestamp是触发事件的时间戳，如果其早于事件处理函数的绑定事件，则不执行事件处理函数</span><br>        <span class="hljs-keyword">if</span> (invoker.<span class="hljs-property">attachTime</span> &amp;&amp; e.<span class="hljs-property">timeStamp</span> &lt; invoker.<span class="hljs-property">attachTime</span>) <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(invoker.<span class="hljs-property">value</span>)) &#123;<br>          <span class="hljs-comment">// 如果 invoker.value 是数组，则遍历它并逐个调用事件处理函数</span><br>          invoker.<span class="hljs-property">value</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(event))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 否则直接调用</span><br>          <span class="hljs-keyword">if</span> (invoker.<span class="hljs-property">value</span>) &#123;<br>            invoker.<span class="hljs-title function_">value</span>(event)<br>          &#125;<br>        &#125;<br>      &#125;<br>      invoker.<span class="hljs-property">value</span> = newVal<br>      <span class="hljs-comment">// 记录绑定时间</span><br>      invoker.<span class="hljs-property">attachTime</span> = performance.<span class="hljs-title function_">now</span>()<br>      el.<span class="hljs-title function_">addEventListener</span>(eventName, invoker)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 有invoker直接更新</span><br>      invoker.<span class="hljs-property">value</span> = newVal<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="更新子节点">更新子节点</span></h2><p>一个<code>vnode</code>的子节点可能有三种情况，那么当渲染器执行更新时，新旧子节点都分别是三种情况之一。</p>
<p><img src="https://pic.imgdb.cn/item/66c71906d9c307b7e9db0246.png"></p>
<p>但落实到代码，我们会发现其实并不需要完全覆盖这九种可能。接下来实现<code>patchElement</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchElement</span>(<span class="hljs-params">oldNode, newNode</span>) &#123;<br>  <span class="hljs-keyword">const</span> el = newNode.<span class="hljs-property">el</span> = oldNode.<span class="hljs-property">el</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Container</span><br>  <span class="hljs-keyword">const</span> oldProps = oldNode.<span class="hljs-property">props</span><br>  <span class="hljs-keyword">const</span> newProps = newNode.<span class="hljs-property">props</span><br>  <span class="hljs-comment">// 更新props</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>    <span class="hljs-keyword">if</span> (newProps[key] !== oldProps[key]) &#123;<br>      <span class="hljs-title function_">patchProps</span>(el, key, oldProps[key], newProps[key])<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将旧Props中不存在于新Props中的属性去掉</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> oldProps) &#123;<br>    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> newProps)) &#123;<br>      <span class="hljs-title function_">patchProps</span>(el, key, oldProps[key], <span class="hljs-literal">null</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 更新子节点</span><br>  <span class="hljs-title function_">patchChild</span>(oldNode, newNode, el)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>更新子节点是对一个元素进行打补丁的最后一步操作。我们将它封装到<code>patchChildren</code>函数中，并将新旧<code>vnode</code>以及当前正在被打补丁的 DOM 元素<code>el</code>作为参数传递给它。新子节点是一组子节时处理涉及diff算法，我们会在后面实现，这里我们先用全部卸载和全部重新挂载来完成。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchChild</span>(<span class="hljs-params">oldNode, newNode, el</span>) &#123;<br>  <span class="hljs-comment">/* 判断新子节点的类型是否为文字节点 */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 旧子节点的类型有三种：没有子节点、文本子节点、一组子节点</span><br>    <span class="hljs-comment">// 当旧子节点为一组子节点时，才需要逐个卸载</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(oldNode.<span class="hljs-property">children</span>)) &#123;<br>      oldNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">unmount</span>(child) &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 最后将新的文本节点内容设置给容器元素</span><br>    el.<span class="hljs-property">textContent</span> = newNode.<span class="hljs-property">children</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(newNode.<span class="hljs-property">children</span>)) &#123;<br>    <span class="hljs-comment">/* 新子节点是一组子节点 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(oldNode.<span class="hljs-property">children</span>)) &#123;<br>      <span class="hljs-comment">// 涉及到diff算法，暂时搁置</span><br>      oldNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">unmount</span>(child) &#125;)<br>      newNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, child, el) &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 旧节点可能是没有子节点或文本子节点，清空容器并重新挂载新子节点</span><br>      el.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;&quot;</span><br>      newNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, child, el) &#125;)<br><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(oldNode.<span class="hljs-property">children</span>)) &#123;<br>      <span class="hljs-comment">// 没有新子节点的情况，直接卸载就可以了</span><br>      oldNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">unmount</span>(child) &#125;)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldNode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 文本节点的情况，直接清空</span><br>      el.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="文本节点和注释节点">文本节点和注释节点</span></h2><p>注释节点与文本节点不同于普通标签节点，它们不具有标签名称，这时候我们需要像实现响应式系统时处理<code>ownKeys</code>类似地人为创造一些唯一的标识，并将其作为注释节点和文本节点的 type 属性值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 文本和注释的唯一标识</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;Text&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Comment</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;Comment&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldNode, newNode, container</span>) &#123;<br>  <span class="hljs-comment">// 如果旧节点存在，则对比新旧节点的type</span><br>  <span class="hljs-keyword">if</span> (oldNode &amp;&amp; oldNode.<span class="hljs-property">type</span> !== newNode.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-comment">// 类型不同则卸载</span><br>    <span class="hljs-title function_">unmount</span>(oldNode)<br>    oldNode = <span class="hljs-literal">undefined</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">type</span> &#125; = newNode<br>  <span class="hljs-comment">// type是string类型，是普通元素</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果不存在旧虚拟节点，则需要挂载，调用mountElement</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-title function_">mountElement</span>(newNode, container)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 存在旧虚拟节点，更新</span><br>      <span class="hljs-title function_">patchElement</span>(oldNode, newNode)<br><br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-comment">// type是object类型，是组件</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-title class_">Text</span>) &#123;<br>    <span class="hljs-comment">// 文本节点</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-comment">// 创建文本节点</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> el = newNode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(newNode.<span class="hljs-property">children</span>)<br>        container.<span class="hljs-title function_">appendChild</span>(el)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Text children is not a string.&quot;</span>)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-title class_">Comment</span>) &#123;<br>    <span class="hljs-comment">// 文本节点</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-comment">// 创建文本节点</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> el = newNode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createComment</span>(newNode.<span class="hljs-property">children</span>)<br>        container.<span class="hljs-title function_">appendChild</span>(el)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Comment children is not a string.&quot;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="fragment"><code>Fragment</code></span></h2><p><code>Fragment</code>（片断）是 Vue.js 3 中新增的一个<code>vnode</code>类型，用于实现多根节点模板（比如列表等）。与文本节点和注释节点类似，片段也没有所谓的标签名称，因此我们也需要为片段创建唯一标识，即 Fragment。</p>
<p>对于<code>Fragment</code>类型的<code>vnode</code>的来说，它的<code>children</code>存储的内容就是模板中所有根节点。有了<code>Fragment</code>后，我们就可以用它来描述<code>Items.vue</code>组件的模板了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Items.vue --&gt;<br>&lt;template&gt;<br>	&lt;li&gt;1&lt;/li&gt;<br>    &lt;li&gt;2&lt;/li&gt;<br>    &lt;li&gt;3&lt;/li&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>对应虚拟节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const Fragment = Symbol()<br>const vnode = &#123;<br>    type: Fragment,<br>    children: [<br>        &#123; type: &#x27;li&#x27;, children: &#x27;1&#x27; &#125;,<br>        &#123; type: &#x27;li&#x27;, children: &#x27;2&#x27; &#125;,<br>        &#123; type: &#x27;li&#x27;, children: &#x27;3&#x27; &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样的对于下面的模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;List&gt;<br>	&lt;Items /&gt;<br>&lt;/List&gt;<br></code></pre></td></tr></table></figure>

<p>对应虚拟节点：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ul&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Fragment</span>,<br>        <span class="hljs-attr">children</span>: [<br>            &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;,<br>            &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;2&#x27;</span> &#125;,<br>            &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;3&#x27;</span> &#125;,<br>        ]<br>    &#125;]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当渲染器渲染 Fragment 类型的虚拟节点时，由于 Fragment 本身并不会渲染任何内容，所以渲染器只会渲染 Fragment 的子节点。<code>patch</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript">...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Fragment&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 旧节点不存在，挂载Fragment的子节点</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode.<span class="hljs-property">children</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        newNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123;<span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, child, container)&#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Fragment children is not a vnode.&quot;</span>)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 旧节点存在，更新Fragment的子节点</span><br>      <span class="hljs-title function_">patchChild</span>(oldNode, newNode, container)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>unmount</code>函数也需要支持<code>Fragment</code>类型的虚拟节点的卸载：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span></span>) &#123;<br>  <span class="hljs-comment">// 如果为Fragment，则卸载所有子节点</span><br>  <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;Fragment&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-title function_">unmount</span>(child))<br>      <span class="hljs-keyword">return</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Fragment children is not a vnode.&quot;</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> parent = vnode.<span class="hljs-property">el</span>.<span class="hljs-property">parentNode</span><br>  <span class="hljs-keyword">if</span> (parent) parent.<span class="hljs-title function_">removeChild</span>(vnode.<span class="hljs-property">el</span>)<br>&#125;<br></code></pre></td></tr></table></figure>


	</article>

	 
    <div class="kira-post-copyright">
        <strong>Author：</strong>破酥 | C4iN<br>
        <strong>Link：</strong><a href="https://c4in1.github.io/2024/08/18/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM-2/" title="https:&#x2F;&#x2F;c4in1.github.io&#x2F;2024&#x2F;08&#x2F;18&#x2F;MVVM&#x2F;实现一个简单的MVVM-2&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;c4in1.github.io&#x2F;2024&#x2F;08&#x2F;18&#x2F;MVVM&#x2F;实现一个简单的MVVM-2&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			          
			<!-- 先找到与当前文字相同的目录 -->
			         
			<!-- 在找到当前文章所在的 index -->
			        
			<!-- 上一篇文章 -->
			<div class="old">
				<span>上一章</span>
				<a href="/2024/08/09/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM-1/"> 实现一个简单的MVVM-1</a>
			</div>
			                      
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/MVVM/">MVVM</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/MVVM/" rel="tag">MVVM</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/Vue/" rel="tag">Vue</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	<div class="giscus"></div>
  
    <script src="https://giscus.app/client.js"
      data-repo="C4in1/BlogGitTalk"
      data-repo-id="R_kgDOMgx61Q"
      data-category="General"
      data-category-id="DIC_kwDOMgx61c4Chec4"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="light"
      data-lang="en"
      data-loading="lazy"
      crossorigin="anonymous"
      async  
    ></script>
  

	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
