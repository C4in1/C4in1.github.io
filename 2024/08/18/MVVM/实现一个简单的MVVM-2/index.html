<!DOCTYPE html>
<html 
	lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> 实现一个简单的MVVM-2 -  C4iN&#39;s Caprice</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="https://pic.imgdb.cn/item/6693875ad9c307b7e98b4288.gif"
			type="image/gif"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('https://pic.imgdb.cn/item/66b458ffd9c307b7e9aadb03.png')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="C4iN&#39;s Caprice">
        <img
			src="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png"
			alt="破酥 | C4iN"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png" title="破酥 | C4iN">
			<img
				src="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png"
				alt="破酥 | C4iN"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>11</div>
		<div><span>标签</span>13</div>
		<div><span>分类</span>6</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/friends"
			title="我的朋友"
		>
			<i
				class="kirafont
					
						icon-team
					"
			></i>
			<div class="kira-list-item-content">
				我的朋友
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2405544030&website=www.oicqzone.com"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/CainHappyfish/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/MVVM/">
              MVVM
            </a>
            <span class="category-list-count">3</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/TypeScript/">
              TypeScript
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/Vue/">
              Vue
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/project/">
              project
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/vitepress/">
              vitepress
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/项目构建/">
              项目构建
            </a>
            <span class="category-list-count">2</span>
          </li>
        
      </ul>
    </div>
  </div>

		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/MVVM/" style="font-size: 14px;">MVVM</a> <a href="/tags/TypeScript/" style="font-size: 18px;">TypeScript</a> <a href="/tags/Typescript/" style="font-size: 10px;">Typescript</a> <a href="/tags/Vitepress/" style="font-size: 12px;">Vitepress</a> <a href="/tags/Vue/" style="font-size: 14px;">Vue</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/theme-censored/" style="font-size: 12px;">theme-censored</a> <a href="/tags/vue3/" style="font-size: 16px;">vue3</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E7%97%9B%E8%8B%A6%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" style="font-size: 12px;">痛苦的配置问题</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83/" style="font-size: 10px;">项目规范</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			Archive
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">11</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2024
		<a href="/">破酥 | C4iN</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><div><span id="busuanzi_container_site_uv">共接待访客<span id="busuanzi_value_site_uv"></span>位</span></div>
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div class="kira-post-cover">
			<img
				data-src="https://pic.imgdb.cn/item/66b47385d9c307b7e9d0b377.png"
				data-sizes="auto"
				alt="实现一个简单的MVVM-2"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>实现一个简单的MVVM-2</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2024年08月18日</a>
			<a><i class="kirafont icon-edit-fill"></i>13k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 60 分钟</a>
		</div>
		<p>这部分我们来介绍MVVM系统的渲染器部分。</p>
<span id="more"></span>

<p>渲染器是用来执行渲染任务的。在浏览器平台上，用它来渲染其中的真实 DOM 元素。渲染器不仅能够渲染真实 DOM 元素，它还是框架跨平台能力的关键。因此，在设计渲染器的时候一定要考虑好可自定义的能力。我们利用响应系统的能力，自动调用渲染器完成页面的渲染和更新，这个过程与渲染器的具体实现无关，仅仅设置了元素的<code>innerHTML</code>内容。</p>
<p><del>玩黑神话中</del></p>
<h1><span id="基本概念">基本概念</span></h1><ul>
<li>渲染器<code>renderer</code>（注意render表示渲染这一动词）：渲染器的作用是把虚拟 DOM 渲染为特定平台上的真实元素。在浏览器平台上，渲染器会把虚拟 DOM 渲染为真实 DOM 元素。</li>
<li>虚拟DOM &amp; 虚拟节点<code>vnode</code>：虚拟 DOM 和真实 DOM 的结构一样，都是由一个个虚拟节点组成的树型结构。</li>
<li>挂载<code>mount</code>：渲染器把虚拟 DOM 节点渲染为真实 DOM 节点的过程叫作挂载。</li>
<li>容器<code>container</code>：渲染器通常需要接收一个挂载点作为参数，用来指定具体的挂载位置。这里的“挂载点”其实就是一个DOM 元素，渲染器会把该 DOM 元素作为容器元素，并把内容渲染到其中，称为容器。</li>
</ul>
<p>描述上述概念之间关系的代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRenderer</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>        ...<br>    &#125;<br>        <br>    <span class="hljs-keyword">return</span> render<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>createRenderer</code>函数用来创建一个<strong>渲染器</strong>。调用<code>createRenderer</code>函数会得到一个 render 函数，该<code>render</code>函数会以<code>container</code>为挂载点，将<code>vnode</code>渲染为真实 DOM并添加到该挂载点下。渲染器不仅包含<code>render</code>函数，还包含<code>hydrate</code>函数等。关于<code>hydrate</code>函数，介绍服务端渲染时会详细讲解。在 Vue.js 3 中，创建应用的<code>createApp</code>函数也是渲染器的一部分。</p>
<p>接下里我们可以调用<code>createRenderer</code>函数创建一个渲染器，接着调用渲染器的<code>renderer.render</code>函数执行渲染。当多次在同一个<code>container</code>上调用<code>renderer.render</code>函数进行渲染时，渲染器除了要执行挂载动作外，还要执行更新动作。</p>
<p>首次渲染时已经把<code>oldVNode</code>渲染到<code>container</code>内了，所以当再次调用<code>renderer.render</code>函数并尝试渲染<code>newVNode</code>时，就不能简单地执行挂载动作了。在这种情况下，渲染器会使用<code>newVNode</code>与上一次渲染的<code>oldVNode</code>进行比较，试图找到并更新变更点。这个过程叫作“打补丁”（或更新，patch），下面是<code>render</code>函数的基本实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRenderer</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>    <span class="hljs-keyword">if</span> (vnode) &#123;<br>      <span class="hljs-comment">// 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数</span><br>      <span class="hljs-title function_">patch</span>(container.<span class="hljs-property">_vnode</span>, vnode, container)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (container.<span class="hljs-property">_vnode</span>) &#123;<br>        <span class="hljs-comment">// 旧 vnode 存在，且新 vnode 不存在，说明是卸载（unmount）操作</span><br>        <span class="hljs-comment">// 只需要将 container 内的 DOM 清空即可</span><br>        container.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&#x27;</span><br>      &#125;<br>    &#125;<br><br>    container.<span class="hljs-property">_vnode</span> = vnode<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> render<br>&#125;<br></code></pre></td></tr></table></figure>

<p>渲染过程：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>()<br><br><span class="hljs-comment">// 首次</span><br>renderer.<span class="hljs-title function_">render</span>(vnode1, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>))<br><span class="hljs-comment">// 第二次</span><br>renderer.<span class="hljs-title function_">render</span>(vnode2, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>))<br><span class="hljs-comment">// 第三次</span><br>renderer.<span class="hljs-title function_">render</span>(<span class="hljs-literal">null</span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>))<br></code></pre></td></tr></table></figure>

<ul>
<li>首次渲染：渲染器会将<code>vnode1</code>渲染为真实 DOM。渲染完成后，<code>vnode1</code>会存储到容器元素的<code>container._vnode</code>属性中，它会在后续渲染中作为旧<code>vnode</code>使用。</li>
<li>第二次渲染：旧<code>vnode</code>存在，此时渲染器会把<code>vnode2</code>作为新<code> vnode</code>，并将新旧<code>vnode</code>一同传递给<code>patch</code>函数进行打补丁。</li>
<li>第三次渲染：新<code>vnode</code>的值为<code> null</code>，即什么都不渲染。但此时容器中渲染的是<code>vnode2</code>所描述的内容，所以渲染器需要清空容器。从上面的代码中可以看出，我们使用<code>container.innerHTML = &#39;&#39;</code>来清空容器。需要注意的是，这样清空容器是有问题的，不过这里我们暂时使用它来达到目的。</li>
</ul>
<p><code>patch</code>函数是整个渲染器的核心入口，它承载了最重要的渲染逻辑。</p>
<ul>
<li>第一个参数：旧<code> vnode</code>。</li>
<li>第二个参数：新<code> vnode</code>。</li>
<li>第三个参数<code> container</code>：容器。</li>
</ul>
<p>在首次渲染时由于容器元素<code>_vnode</code>不存在，传递给 patch 函数的第一个参数<code>n1</code>是<code> undefined</code>。这时，<code>patch</code>函数会执行挂载动作，它会忽略<code> n1</code>，并直接将<code>n2</code>所描述的内容渲染到容器中。从这一点可以看出，<code>patch </code>函数不仅可以用来完成打补丁，也可以用来执行挂载。</p>
<h1><span id="自定义渲染器">自定义渲染器</span></h1><p>我们将以浏览器作为渲染的目标平台，编写一个渲染器。</p>
<p>我们用下面的数据结果定义<code>VNode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VNode</span> &#123;<br><br>  <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 用于存放vnode的特性和属性</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">props</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">symbol</span> | <span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;<br>  <span class="hljs-attr">children</span>: <span class="hljs-built_in">string</span> | <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">VNode</span>&gt;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * DOM属性，可以是HTML元素容器，文本节点以及注释</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span> | <span class="hljs-title class_">Text</span> | <span class="hljs-title class_">Comment</span><br>  <span class="hljs-comment">// 唯一标识</span><br>  <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">symbol</span> | <span class="hljs-literal">undefined</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们实现<code>patch</code>函数，结构如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params"><span class="hljs-attr">oldNode</span>: <span class="hljs-title class_">VNode</span> | <span class="hljs-literal">undefined</span>, <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-comment">// 如果不存在旧虚拟节点，则需要挂载，调用mountElement</span><br>  <span class="hljs-keyword">if</span> (oldNode) &#123;<br>    <span class="hljs-title function_">mountElement</span>(newNode, container)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 存在旧虚拟节点，更新</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们先来看<code>mountElement</code>是如何挂载的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-comment">// 创建HTML元素</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">type</span>)<br>  <br>  <span class="hljs-comment">// 挂载</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">/* 如果子节点是字符串，则说明是文本节点 */</span><br>    el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">children</span><br>  &#125; <br><br>  <span class="hljs-comment">// 将元素添加到挂载点下</span><br>  container.<span class="hljs-title function_">appendChild</span>(el)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先调用<code>document.createElement</code>函数，以<code>vnode.type</code>的值作为标签名称创建新的 DOM 元素。接着处理<code>vnode.children</code>，如果它的值是字符串类型，则代表该元素具有文本子节点，这时只需要设置元素的<code>textContent</code>即可。最后调用<code>appendChild</code>函数将新创建的<code>DOM</code>元素添加到容器元素内。这样，我们就完成了一个<code>vnode</code>的挂载。</p>
<p>我们的目标是设计一个不依赖于浏览器平台的通用渲染器，因此我们需要将浏览器特有的 API 抽离。我们把用于操作 DOM 的 API 封装为一个对象，并把它传递给<code>createRenderer</code>函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>(&#123;<br>    <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag)<br>    &#125;,<br>    <span class="hljs-title function_">setElementTest</span>(<span class="hljs-params">el, text</span>) &#123;<br>        el.<span class="hljs-property">textContent</span> = text<br>    &#125;,<br>    <span class="hljs-title function_">insert</span>(<span class="hljs-params">el, parent, anchor = <span class="hljs-literal">null</span></span>) &#123;<br>        parent.<span class="hljs-title function_">insertBefore</span>(el, anchor)<br>    &#125;<br>&#125;)<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRenderer</span>(<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;<br>        createElement,<br>        insert,<br>        setElementText<br>    &#125; = options<br>    <br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样我们就可以从配置项中直接读取对应的API。</p>
<h1><span id="挂载和更新">挂载和更新</span></h1><h2><span id="子节点">子节点</span></h2><p>一个元素除了具有文本子节点外，还可以包含其他元素子节点，并且子节点可以是很多个。当<code>vnode</code>含有标签属性<code>props</code>时，我们需要将这些属性渲染到真实DOM中。<code>HTML</code>标签有很多属性，其中有些属性是通用的，例如 id、class 等，而有些属性是特定元素才有的，例如<code>form</code>元素的<code>action</code>属性。修改<code>mountElement</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-comment">// 创建HTML元素</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">type</span>)<br><br>  <span class="hljs-comment">// 遍历props，将属性、事件添加到元素</span><br>  <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) &#123;<br>      <span class="hljs-comment">/* 添加props到元素的属性、事件中 */</span><br>      <span class="hljs-title function_">patchProps</span>(vnode, container, key)<br>    &#125;<br><br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">/* 如果子节点是字符串，则说明是文本节点*/</span><br>    el.<span class="hljs-property">textContent</span> = vnode.<span class="hljs-property">children</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(vnode.<span class="hljs-property">children</span>)) &#123;<br>    <span class="hljs-comment">/* 如果子节点是数组，则递归调用mountElement，遍历所有子节点 */</span><br>    vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> <span class="hljs-title function_">mountElement</span>(child, el))<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Wrong Type&quot;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 将元素添加到挂载点下</span><br>  container.<span class="hljs-title function_">appendChild</span>(el)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>patchProps</code>用于挂载和更新 DOM 属性信息，我们针对不同的属性，逐步实现<code>patchProps</code>。在开始之前，我们先回顾一下<code>HTML Attrs</code>和<code>DOM Props</code>。</p>
<h2><span id="元素属性">元素属性</span></h2><p><code>HTML Attributes</code>指的就是定义在 HTML 标签上的属性。当浏览器解析 HTML 代码后，会创建一个与之相符的 DOM 元素对象，我怕们可以用JS代码获取该 DOM 对象。这个 DOM 对象会包含很多属性（properties），这些属性就是所谓的 DOM Properties。很多<code>HTML Attributes</code>在 DOM 对象上有与之同名的<code> DOM Properties</code>，但两者除了名字不总相同外，并不是所有<code>HTML Attrs</code>都有对应的<code>DOM props</code>。类似地，也不是所有<code>DOM Properties</code>都有与之对应的<code> HTML Attributes</code>。</p>
<p>不是所有<code>HTML Attributes</code>与<code>DOM Properties</code>之间都是像<code>id</code>那样直接映射的关系。实际上，<code>HTML Attributes </code>的作用是设置与之对应的<code>DOM Properties</code>的<strong>初始值</strong>。一旦值改变，那么<code>DOM Properties</code>始终存储着当前值，而通过<code>getAttribute</code>函数得到的仍然是初始值。一个<code>HTML Attributes</code>可能关联多个<code> DOM Properties</code>。</p>
<p>我们只需要记住一个核心原则即可：<code>HTML Attributes</code>的作用是设置与之对应的<code>DOM Properties</code>的初始值。</p>
<p>无论是使用<code>setAttribute</code>函数，还是直接设置元素的<code> DOM Properties</code>，都存在缺陷。要彻底解决这个问题，我们只能做特殊处理，即优先设置元素的<code> DOM Properties</code>，但当值为空字符串时，要手动将值矫正为<code> true</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">patchProps</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>:<span class="hljs-title class_">VNode</span>, <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span>, <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-comment">// 判断是否存在对应的DOM props</span><br>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> el) &#123;<br>    <span class="hljs-comment">// 获取HTML Attrs值</span><br>    <span class="hljs-keyword">const</span> attributeValue = el.<span class="hljs-title function_">getAttribute</span>(key)<br>    <span class="hljs-comment">// 获取props值</span><br>    <span class="hljs-keyword">const</span> propValue = vnode.<span class="hljs-property">props</span>[key]<br>    <span class="hljs-comment">// 如果是布尔类型，并且 value 是空字符串，则将值矫正为 true, 如disabled</span><br>    <span class="hljs-keyword">if</span> (attributeValue === <span class="hljs-string">&quot;&quot;</span> || propValue === <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      el.<span class="hljs-title function_">setAttribute</span>(key, <span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      el.<span class="hljs-title function_">setAttribute</span>(key, propValue)<br>    &#125;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们需要把属性的设置也变成与平台无关，因此需要把属性设置相关操作也提取到渲染器选项中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> renderer = <span class="hljs-title function_">createRenderer</span>(&#123;<br>    <span class="hljs-title function_">createElement</span>(<span class="hljs-params">tag</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(tag)<br>    &#125;,<br>    <span class="hljs-title function_">setElementTest</span>(<span class="hljs-params">el, text</span>) &#123;<br>        el.<span class="hljs-property">textContent</span> = text<br>    &#125;,<br>    <span class="hljs-title function_">insert</span>(<span class="hljs-params">el, parent, anchor = <span class="hljs-literal">null</span></span>) &#123;<br>        parent.<span class="hljs-title function_">insertBefore</span>(el, anchor)<br>    &#125;,<br>    <span class="hljs-title function_">patchProps</span>(<span class="hljs-params">el, key, prevValue, nextValue</span>) &#123;<br>        ...<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h2><span id="class"><code>class</code></span></h2><p>Vue中为元素设置<code>class</code>有很多种方法：</p>
<ul>
<li><p><code>class=&quot;class1 class2&quot;</code>，指定 class 为一个字符串值</p>
<p>对应<code>vnode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>    <span class="hljs-attr">props</span>: &#123;<br>    	<span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;class1 class2&#x27;</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>:class=&quot;class1&quot;</code>，指定 class 为一个对象</p>
<p>对应<code>vnode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> class1 = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span> &#125;<br><br><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>    <span class="hljs-attr">props</span>: &#123;<br>    	<span class="hljs-attr">class</span>: &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span> &#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>:class=&quot;arr&quot;</code>，指定 class 为一个数组</p>
<p>对应<code>vnode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">class</span> = [<br>    <span class="hljs-string">&#x27;class1&#x27;</span>,<br>    &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span> &#125;<br>]<br><br><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>    <span class="hljs-attr">props</span>: &#123;<br>    	<span class="hljs-attr">class</span>: [<br>            <span class="hljs-string">&#x27;class1&#x27;</span>,<br>            &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span> &#125;<br>        ]<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>因为 class 的值可以是多种类型，所以我们必须在设置元素的 class 之前将值归一化为统一的字符串形式，再把该字符串作为元素的 class 值去设置。我们简单实现<code>normalizeClass</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">normalizeClass</span>(<span class="hljs-params">classSeries</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">className</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = []<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> classSeries == <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> classSeries<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> classSeries === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; !<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(classSeries)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">normalizeObject</span>(classSeries)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(classSeries)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">normalizeArray</span>(classSeries)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;class type should be string, object or array.&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 标准化对象</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">normalizeObject</span>(<span class="hljs-params"><span class="hljs-attr">classSeries</span>: &#123;[index: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>]: <span class="hljs-built_in">boolean</span>&#125;</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">objectString</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = []<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(classSeries).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> classSeries[key] !== <span class="hljs-string">&#x27;boolean&#x27;</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`class value <span class="hljs-subst">$&#123;<span class="hljs-built_in">String</span>(key)&#125;</span> must be a boolean.`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (classSeries[key]) &#123;<br>        objectString.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">String</span>(key))<br>      &#125;<br><br>    &#125;)<br>    <span class="hljs-keyword">return</span> objectString.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>)<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 标准化数组</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">normalizeArray</span>(<span class="hljs-params"><span class="hljs-attr">classSeries</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;</span>) &#123;<br>    classSeries.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">item</span>: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        className.<span class="hljs-title function_">push</span>(item)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> item === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">normalizeObject</span>(item)) &#123;<br>          className.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">normalizeObject</span>(item))<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`class value <span class="hljs-subst">$&#123;item&#125;</span> must be a string or object.`</span>)<br>      &#125;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item, className)<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> className.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot; &quot;</span>)<br>  &#125;<br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们知道，在浏览器中为一个元素设置 class 有三种方式，即使用<code>setAttribute</code>、<code>el.className</code>或<code>el.classList</code>。其中<code>el.className</code>的性能最优。在<code>patchProps</code>添加对应逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (attributeValue === <span class="hljs-string">&quot;&quot;</span> || propValue === <span class="hljs-string">&quot;&quot;</span>) &#123;<br>      el.<span class="hljs-title function_">setAttribute</span>(key, <span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>))<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;class&#x27;</span>) &#123;<br>      el.<span class="hljs-property">className</span> = vnode.<span class="hljs-property">props</span>[key]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      el.<span class="hljs-title function_">setAttribute</span>(key, propValue)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了 class 属性之外，我们也需要对<code>style</code>做类似的处理，不同的是不需要在<code>patchProps</code>添加对应逻辑处理style，这里就不做过多叙述。</p>
<h2><span id="卸载">卸载</span></h2><p>卸载操作发生在更新阶段，更新指的是，在初次挂载完成之后，后续渲染会触发更新。首次挂载完成后，后续渲染时如果传递了 null 作为新<code> vnode</code>，则意味着什么都不渲染，这时我们需要卸载之前渲染的内容。</p>
<p>回顾之前的<code>render</code>函数，我们直接通过<code>innerHTML</code>清空容器，这么做是不严谨的：</p>
<ul>
<li>容器的内容可能是由某个或多个组件渲染的，当卸载操作发生时，应该正确地调用这些组件的<code> beforeUnmount</code>、<code>unmounted</code>等生命周期函数。</li>
<li>即使内容不是由组件渲染的，有的元素存在自定义指令，我们应该在卸载操作发生时正确执行对应的指令钩子函数。</li>
<li>使用<code>innerHTML</code>清空容器元素内容的另一个缺陷是，它不会移除绑定在 DOM 元素上的事件处理函数。</li>
</ul>
<p>正确的卸载方式是，根据<code>vnode</code>对象获取与其相关联的真实 DOM 元素，然后使用原生 DOM 操作方法将该 DOM 元素移除。为此，我们需要在<code>vnode</code>与真实 DOM 元素之间建立联系，修改<code>mountElement</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 创建HTML元素，建立vnode与DOM之间的联系</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span> = vnode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">type</span>)<br></code></pre></td></tr></table></figure>

<p>当卸载操作发生的时候，只需要根据虚拟节点对象<code>vnode.el</code>取得真实 DOM 元素，再将其从父元素中移除：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params">vnode</span>) &#123;<br>    <span class="hljs-keyword">const</span> parent = vnode.<span class="hljs-property">el</span>.<span class="hljs-property">parentNode</span><br>    <span class="hljs-keyword">if</span> (parent) parent.<span class="hljs-title function_">removeChild</span>(vnode.<span class="hljs-property">el</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>unmount</code>函数内，我们有机会调用绑定在 DOM 元素上的指令钩子函数，例如<code> beforeUnmount</code>、<code>unmounted</code>等。当<code>unmount</code>函数执行时，我们有机会检测虚拟节点<code>vnode</code>的类型。如果该虚拟节点描述的是组件，则我们有机会调用组件相关的生命周期函数。</p>
<h2><span id="区分vnode">区分<code>vnode</code></span></h2><p>如果修改前后<code>vnode.type</code>属性的值不同，会造成新旧<code>vnode</code>所描述的内容不同，对于不同的元素来说，每个元素都有特有的属性。在这种情况下，正确的更新操作是，先将原元素卸载，再将新元素挂载到容器中。修改<code>patch</code>函数代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldNode, newNode, container</span>) &#123;<br>  <span class="hljs-comment">// 如果旧节点存在，则对比新旧节点的type</span><br>  <span class="hljs-keyword">if</span> (oldNode &amp;&amp; oldNode.<span class="hljs-property">type</span> !== newNode.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-comment">// 类型不同则卸载</span><br>    <span class="hljs-title function_">unmount</span>(oldNode)<br>    oldNode = <span class="hljs-literal">undefined</span><br>  &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>即使新旧<code>vnode</code>描述的内容相同，我们仍然需要进一步确认它们的类型是否相同。我们知道，一个<code>vnode</code>可以用来描述普通标签，也可以用来描述组件，还可以用来描述<code>Fragment</code>等。对于不同类型的<code>vnode</code>，我们需要提供不同的挂载或打补丁的处理方式。所以，我们需要继续修改<code>patch</code>函数的代码以满足需求：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// type是string类型，是普通元素</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果不存在旧虚拟节点，则需要挂载，调用mountElement</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-title function_">mountElement</span>(newNode, container)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 存在旧虚拟节点，更新</span><br>      <span class="hljs-title function_">patchElement</span>(oldNode, newNode)<br><br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-comment">// type是object类型，是组件</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="事件处理">事件处理</span></h2><p>事件可以视作一种特殊的属性，因此我们可以约定，在<code>vnode.props</code>对象中，凡是以字符串<code>on</code>开头的属性都视作事件。将事件添加到 DOM 元素上只需要在<code>patchProps</code>中调用<code> addEventListener</code>函数来绑定事件即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">...<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^on/</span>.<span class="hljs-title function_">test</span>(key)) &#123;<br>  <span class="hljs-keyword">const</span> event = key.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>()<br>  <span class="hljs-comment">// const invokers = el._invokers || (el._invokers = &#123;&#125;)</span><br>  <span class="hljs-comment">// let invoker: Invoker = invokers[event]</span><br>  el.<span class="hljs-title function_">addEventListener</span>(event, <span class="hljs-function">() =&gt;</span> &#123;<br>    vnode.<span class="hljs-property">props</span>[key]()<br>  &#125;)<br>&#125; <br><br>...<br></code></pre></td></tr></table></figure>

<p>当事件更新时，我们绑定一个伪造的事件处理函数<code>invoker</code>，然后把真正的事件处理函数设置为<code> invoker.value</code>属性的值。这样当更新事件的时候，我们将不再需要调用<code>removeEventListener</code>函数来移除上一次绑定的事件，只需要更新<code>invoker.value</code>的值。我们还需要在同一个时刻缓存多个事件处理函数，所以我们需要用一个对象来存储所有的事件处理函数，否则将会出现事件覆盖的现象。这个对象的键值是事件名称，而值则是对应的事件处理函数。而对于同一事件的不同处理函数，我们用数组来存取：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* 事件处理 */</span><br><span class="hljs-keyword">const</span> eventName = key.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>()<br><span class="hljs-comment">// 获取所有事件处理函数，如果不存在则新建一个</span><br><span class="hljs-keyword">const</span> invokers = el.<span class="hljs-property">_invokers</span> || (el.<span class="hljs-property">_invokers</span> = &#123;&#125;)<br><span class="hljs-keyword">let</span> <span class="hljs-attr">invoker</span>: <span class="hljs-title class_">Invoker</span> = invokers[eventName]<br><br><span class="hljs-keyword">if</span>(newVal) &#123;<br><span class="hljs-comment">/* 如果invoker不存在，则初始化 */</span><br><span class="hljs-keyword">if</span> (!invoker) &#123;<br>  <span class="hljs-comment">// 将事件处理函数缓存到el._invokers</span><br>  invoker = el.<span class="hljs-property">_invokers</span>[eventName] = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">Event</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(invoker.<span class="hljs-property">value</span>)) &#123;<br>      <span class="hljs-comment">// 如果 invoker.value 是数组，则遍历它并逐个调用事件处理函数</span><br>      invoker.<span class="hljs-property">value</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(event))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则直接调用</span><br>      <span class="hljs-keyword">if</span> (invoker.<span class="hljs-property">value</span>) &#123;<br>        invoker.<span class="hljs-title function_">value</span>(event)<br>      &#125;<br>    &#125;<br>  &#125;<br>  invoker.<span class="hljs-property">value</span> = newVal<br>  el.<span class="hljs-title function_">addEventListener</span>(eventName, invoker)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 有invoker直接更新</span><br>  invoker.<span class="hljs-property">value</span> = newVal<br>&#125;<br><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (invoker) &#123;<br>  <span class="hljs-comment">/* 如果没有新的事件绑定函数，移除原有事件监听 */</span><br>  el.<span class="hljs-title function_">removeEventListener</span>(eventName, invoker)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3><span id="事件冒泡与更新时机">事件冒泡与更新时机</span></h3><p>我们来看一个小例子：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> bol = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br><br><span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> vnode = &#123;<br>        <span class="hljs-keyword">type</span> = <span class="hljs-string">&#x27;div&#x27;</span>,<br>        <span class="hljs-attr">props</span>: bol.<span class="hljs-property">value</span> ? &#123;<br>            <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>                <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;parent clicked&quot;</span>)<br>            &#125;<br>    	&#125; : &#123;&#125;,<br>    	<br>    	<span class="hljs-attr">children</span>: [&#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>            <span class="hljs-attr">props</span>: &#123;<br>                <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>                    bol.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;,<br>            <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;text&quot;</span><br>        &#125;],          <br>    &#125;<br>    <br>    <span class="hljs-comment">// 渲染</span><br>    renderer.<span class="hljs-title function_">render</span>(vnode, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;#app&quot;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>运行上面这段代码并点击<code>p</code>元素时，会发现父级<code>div</code>元素的<code>click</code>事件的事件处理函数竟然执行了，这其实与更新机制有关。</p>
<p>当点击 p 元素时，绑定到它身上的 click 事件处理函数会执行，于是<code>bol.value</code>的值被改为<code> true</code>。接下来的一步非常关键，由于<code>bol</code>是一个响应式数据，所以当它的值发生变化时，会触发副作用函数重新执行。由于此时的<code>bol.value</code>已经变成了<code> true</code>，所以在更新阶段，渲染器会为父级<code>div</code>元素绑定<code>click</code>事件处理函数。当更新完成之后，点击事件才从<code>p</code>元素冒泡到父级<code>div</code>元素。由于此时<code>div</code>元素已经绑定了<code>click</code>事件的处理函数，因此就发生了上述现象。</p>
<p>之所以会出现上述奇怪的现象，是因为更新操作发生在事件冒泡之前，即为 div 元素绑定事件处理函数发生在事件冒泡之前。</p>
<p><img src="https://pic.imgdb.cn/item/66c710cdd9c307b7e9d42aec.png"></p>
<p>事件触发的时间要早于事件处理函数被绑定的时间。这意味着当一个事件触发时，目标元素上还没有绑定相关的事件处理函数，我们可以根据这个特点来解决问题：<strong>屏蔽所有绑定时间晚于事件触发时间的事件处理函数的执行</strong>。</p>
<p>我们为<code>invoker</code>增加一个事件处理函数绑定时间<code>attachTime</code>，如果绑定时间晚于事件发生时间，则不执行事件处理函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (!invoker) &#123;<br>      <span class="hljs-comment">// 将事件处理函数缓存到el._invokers</span><br>      invoker = el.<span class="hljs-property">_invokers</span>[eventName] = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">Event</span></span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// timestamp是触发事件的时间戳，如果其早于事件处理函数的绑定事件，则不执行事件处理函数</span><br>        <span class="hljs-keyword">if</span> (invoker.<span class="hljs-property">attachTime</span> &amp;&amp; e.<span class="hljs-property">timeStamp</span> &lt; invoker.<span class="hljs-property">attachTime</span>) <span class="hljs-keyword">return</span><br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(invoker.<span class="hljs-property">value</span>)) &#123;<br>          <span class="hljs-comment">// 如果 invoker.value 是数组，则遍历它并逐个调用事件处理函数</span><br>          invoker.<span class="hljs-property">value</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>(event))<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 否则直接调用</span><br>          <span class="hljs-keyword">if</span> (invoker.<span class="hljs-property">value</span>) &#123;<br>            invoker.<span class="hljs-title function_">value</span>(event)<br>          &#125;<br>        &#125;<br>      &#125;<br>      invoker.<span class="hljs-property">value</span> = newVal<br>      <span class="hljs-comment">// 记录绑定时间</span><br>      invoker.<span class="hljs-property">attachTime</span> = performance.<span class="hljs-title function_">now</span>()<br>      el.<span class="hljs-title function_">addEventListener</span>(eventName, invoker)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 有invoker直接更新</span><br>      invoker.<span class="hljs-property">value</span> = newVal<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="更新子节点">更新子节点</span></h2><p>一个<code>vnode</code>的子节点可能有三种情况，那么当渲染器执行更新时，新旧子节点都分别是三种情况之一。</p>
<p><img src="https://pic.imgdb.cn/item/66c71906d9c307b7e9db0246.png"></p>
<p>但落实到代码，我们会发现其实并不需要完全覆盖这九种可能。接下来实现<code>patchElement</code>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchElement</span>(<span class="hljs-params">oldNode, newNode</span>) &#123;<br>  <span class="hljs-keyword">const</span> el = newNode.<span class="hljs-property">el</span> = oldNode.<span class="hljs-property">el</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Container</span><br>  <span class="hljs-keyword">const</span> oldProps = oldNode.<span class="hljs-property">props</span><br>  <span class="hljs-keyword">const</span> newProps = newNode.<span class="hljs-property">props</span><br>  <span class="hljs-comment">// 更新props</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>    <span class="hljs-keyword">if</span> (newProps[key] !== oldProps[key]) &#123;<br>      <span class="hljs-title function_">patchProps</span>(el, key, oldProps[key], newProps[key])<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 将旧Props中不存在于新Props中的属性去掉</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> oldProps) &#123;<br>    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> newProps)) &#123;<br>      <span class="hljs-title function_">patchProps</span>(el, key, oldProps[key], <span class="hljs-literal">null</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 更新子节点</span><br>  <span class="hljs-title function_">patchChild</span>(oldNode, newNode, el)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>更新子节点是对一个元素进行打补丁的最后一步操作。我们将它封装到<code>patchChildren</code>函数中，并将新旧<code>vnode</code>以及当前正在被打补丁的 DOM 元素<code>el</code>作为参数传递给它。新子节点是一组子节时处理涉及diff算法，我们会在后面实现，这里我们先用全部卸载和全部重新挂载来完成。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchChild</span>(<span class="hljs-params">oldNode, newNode, el</span>) &#123;<br>  <span class="hljs-comment">/* 判断新子节点的类型是否为文字节点 */</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 旧子节点的类型有三种：没有子节点、文本子节点、一组子节点</span><br>    <span class="hljs-comment">// 当旧子节点为一组子节点时，才需要逐个卸载</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(oldNode.<span class="hljs-property">children</span>)) &#123;<br>      oldNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">unmount</span>(child) &#125;)<br>    &#125;<br><br>    <span class="hljs-comment">// 最后将新的文本节点内容设置给容器元素</span><br>    el.<span class="hljs-property">textContent</span> = newNode.<span class="hljs-property">children</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(newNode.<span class="hljs-property">children</span>)) &#123;<br>    <span class="hljs-comment">/* 新子节点是一组子节点 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(oldNode.<span class="hljs-property">children</span>)) &#123;<br>      <span class="hljs-comment">// 涉及到diff算法，暂时搁置</span><br>      oldNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">unmount</span>(child) &#125;)<br>      newNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, child, el) &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 旧节点可能是没有子节点或文本子节点，清空容器并重新挂载新子节点</span><br>      el.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;&quot;</span><br>      newNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, child, el) &#125;)<br><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(oldNode.<span class="hljs-property">children</span>)) &#123;<br>      <span class="hljs-comment">// 没有新子节点的情况，直接卸载就可以了</span><br>      oldNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123; <span class="hljs-title function_">unmount</span>(child) &#125;)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldNode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 文本节点的情况，直接清空</span><br>      el.<span class="hljs-property">textContent</span> = <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="文本节点和注释节点">文本节点和注释节点</span></h2><p>注释节点与文本节点不同于普通标签节点，它们不具有标签名称，这时候我们需要像实现响应式系统时处理<code>ownKeys</code>类似地人为创造一些唯一的标识，并将其作为注释节点和文本节点的 type 属性值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 文本和注释的唯一标识</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Text</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;Text&#x27;</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Comment</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;Comment&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">oldNode, newNode, container</span>) &#123;<br>  <span class="hljs-comment">// 如果旧节点存在，则对比新旧节点的type</span><br>  <span class="hljs-keyword">if</span> (oldNode &amp;&amp; oldNode.<span class="hljs-property">type</span> !== newNode.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-comment">// 类型不同则卸载</span><br>    <span class="hljs-title function_">unmount</span>(oldNode)<br>    oldNode = <span class="hljs-literal">undefined</span><br>  &#125;<br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">type</span> &#125; = newNode<br>  <span class="hljs-comment">// type是string类型，是普通元素</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 如果不存在旧虚拟节点，则需要挂载，调用mountElement</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-title function_">mountElement</span>(newNode, container)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 存在旧虚拟节点，更新</span><br>      <span class="hljs-title function_">patchElement</span>(oldNode, newNode)<br><br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-comment">// type是object类型，是组件</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-title class_">Text</span>) &#123;<br>    <span class="hljs-comment">// 文本节点</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-comment">// 创建文本节点</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> el = newNode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(newNode.<span class="hljs-property">children</span>)<br>        container.<span class="hljs-title function_">appendChild</span>(el)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Text children is not a string.&quot;</span>)<br>      &#125;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-title class_">Comment</span>) &#123;<br>    <span class="hljs-comment">// 文本节点</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-comment">// 创建文本节点</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> el = newNode.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createComment</span>(newNode.<span class="hljs-property">children</span>)<br>        container.<span class="hljs-title function_">appendChild</span>(el)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Comment children is not a string.&quot;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="fragment"><code>Fragment</code></span></h2><p><code>Fragment</code>（片断）是 Vue.js 3 中新增的一个<code>vnode</code>类型，用于实现多根节点模板（比如列表等）。与文本节点和注释节点类似，片段也没有所谓的标签名称，因此我们也需要为片段创建唯一标识，即 Fragment。</p>
<p>对于<code>Fragment</code>类型的<code>vnode</code>的来说，它的<code>children</code>存储的内容就是模板中所有根节点。有了<code>Fragment</code>后，我们就可以用它来描述<code>Items.vue</code>组件的模板了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- Items.vue --&gt;<br>&lt;template&gt;<br>	&lt;li&gt;1&lt;/li&gt;<br>    &lt;li&gt;2&lt;/li&gt;<br>    &lt;li&gt;3&lt;/li&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure>

<p>对应虚拟节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const Fragment = Symbol()<br>const vnode = &#123;<br>    type: Fragment,<br>    children: [<br>        &#123; type: &#x27;li&#x27;, children: &#x27;1&#x27; &#125;,<br>        &#123; type: &#x27;li&#x27;, children: &#x27;2&#x27; &#125;,<br>        &#123; type: &#x27;li&#x27;, children: &#x27;3&#x27; &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样的对于下面的模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;List&gt;<br>	&lt;Items /&gt;<br>&lt;/List&gt;<br></code></pre></td></tr></table></figure>

<p>对应虚拟节点：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> vnode = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ul&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Fragment</span>,<br>        <span class="hljs-attr">children</span>: [<br>            &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;,<br>            &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;2&#x27;</span> &#125;,<br>            &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;3&#x27;</span> &#125;,<br>        ]<br>    &#125;]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当渲染器渲染 Fragment 类型的虚拟节点时，由于 Fragment 本身并不会渲染任何内容，所以渲染器只会渲染 Fragment 的子节点。<code>patch</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript">...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Fragment&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 旧节点不存在，挂载Fragment的子节点</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newNode.<span class="hljs-property">children</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>        newNode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">VNode</span></span>) =&gt;</span> &#123;<span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, child, container)&#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Fragment children is not a vnode.&quot;</span>)<br>      &#125;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 旧节点存在，更新Fragment的子节点</span><br>      <span class="hljs-title function_">patchChild</span>(oldNode, newNode, container)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>unmount</code>函数也需要支持<code>Fragment</code>类型的虚拟节点的卸载：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">unmount</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span></span>) &#123;<br>  <span class="hljs-comment">// 如果为Fragment，则卸载所有子节点</span><br>  <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">type</span> === <span class="hljs-string">&quot;Fragment&quot;</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> <span class="hljs-title function_">unmount</span>(child))<br>      <span class="hljs-keyword">return</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Fragment children is not a vnode.&quot;</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> parent = vnode.<span class="hljs-property">el</span>.<span class="hljs-property">parentNode</span><br>  <span class="hljs-keyword">if</span> (parent) parent.<span class="hljs-title function_">removeChild</span>(vnode.<span class="hljs-property">el</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h1><span id="简单diff算法">简单diff算法</span></h1><p>当新旧节点的类型相同时，我们只需要修改更新过的内容，因此不需要删除和挂载操作。但新旧子节点数量未必相同，当新子节点组数量少于旧子节点组时，有些节点需要在更新后被卸载，同样的，如果新子节点组中存在旧子节点没有的节点时，也需要挂载新的节点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 获取新旧子节点组的信息</span><br><span class="hljs-keyword">const</span> oldChildren = oldNode.<span class="hljs-property">children</span><br><span class="hljs-keyword">const</span> newChildren = newNode.<span class="hljs-property">children</span><br><br><span class="hljs-keyword">const</span> oldLen = oldChildren.<span class="hljs-property">length</span><br><span class="hljs-keyword">const</span> newLen = newChildren.<span class="hljs-property">length</span><br><br><span class="hljs-comment">// 获得新旧子节点组的共同长度</span><br><span class="hljs-keyword">const</span> commonLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(oldLen, newLen)<br><br><span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(oldChildren)) &#123;<br>  <span class="hljs-comment">// 遍历commonLength次</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; commonLength; i++) &#123;<br>    <span class="hljs-title function_">patch</span>(oldChildren[i], newChildren[i], el)<br>  &#125;<br>  <span class="hljs-comment">/* newLen &gt; oldLen， 需要挂载新子节点 */</span><br>  <span class="hljs-keyword">if</span> (newLen &gt; oldLen) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = commonLength; i &lt;= newLen; i++) &#123;<br>      <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, newChildren[i], el)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newLen &lt; newLen) &#123;<br>    <span class="hljs-comment">/* newLen &lt; oldLen， 需要卸载旧子节点 */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = commonLength; i &lt;= oldLen; i++) &#123;<br>      <span class="hljs-title function_">unmount</span>(oldChildren[i])<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="dom复用">DOM复用</span></h2><p>当我们遇到新子节点组相较于旧子节点组只是交换顺序时，我们就要用到<code>vnode</code>的唯一标识<code>key</code>来处理更新事件。只要两个虚拟节点的<code>type</code>属性值和<code>key</code>属性值都相同，那么我们就认为它们是相同的，即可以进行 DOM 的复用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 遍历新旧节点，找出key相同的子节点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; newLen; i++) &#123;<br>  <span class="hljs-keyword">const</span> newVNode = newChildren[i]<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span> ; j &lt; oldLen; j++) &#123;<br>    <span class="hljs-keyword">const</span> oldVNode = oldChildren[j]<br>    <span class="hljs-keyword">if</span> (newVNode === oldVNode) &#123;<br>      <span class="hljs-comment">// 找到相同节点，则先更新后跳出内循环</span><br>      <span class="hljs-title function_">patch</span>(oldVNode, newVNode, el)<br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来处理节点移动问题。每一次寻找可复用的节点时，都会记录该可复用节点在旧的一组子节点中的位置索引。把这些位置索引值按照先后顺序排列，如果顺序递增，则不需要移动任何节点，否则需要移动真实 DOM 。在旧<code>children</code>中寻找具有相同 key 值节点的过程中，遇到的最大索引值。如果在后续寻找的过程中，存在索引值比当前遇到的最大索引值还要小的节点，则意味着该节点需要移动。</p>
<p><img src="https://pic.imgdb.cn/item/66c998ffd9c307b7e91553bb.png"></p>
<p>移动节点指的是移动一个虚拟节点所对应的真实 DOM 节点，并不是移动虚拟节点本身。在代码中，我们可以通过旧子节点的<code>vnode.el</code>属性取得它对应的真实 DOM 节点。<code>patchElement</code>函数首先将旧节点的<code>n1.el</code>属性赋值给新节点的<code>n2.el</code>属性。这个赋值语句的真正含义其实就是 DOM 元素的复用。我们知道，新 children 的顺序其实就是更新后真实 DOM 节点应有的顺序。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 存储遍历过程中遇到的最大索引</span><br><span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; newLen; i++) &#123;<br>  <span class="hljs-keyword">const</span> newVNode = newChildren[i]<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span> ; j &lt; oldLen; j++) &#123;<br>    <span class="hljs-keyword">const</span> oldVNode = oldChildren[j]<br>    <span class="hljs-keyword">if</span> (newVNode === oldVNode) &#123;<br>      <span class="hljs-comment">// 找到相同节点，则先更新后跳出内循环</span><br>      <span class="hljs-title function_">patch</span>(oldVNode, newVNode, el)<br>      <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>        <span class="hljs-comment">// 需要移动，先获取newVNode的前一个节点prevVNode</span><br>        <span class="hljs-keyword">const</span> prevVNode = newChildren[i - <span class="hljs-number">1</span>]<br>        <span class="hljs-comment">// 如果不存在prevNode说明是新子节点组第一个元素，则不需要移动，作为DOM树的第一个子节点来帮助定位</span><br>        <span class="hljs-keyword">if</span> (prevVNode) &#123;<br>          <span class="hljs-comment">// 获取prevVNode对应真实DOM的下一个兄弟节点作为锚点，插入newVNode</span><br>          <span class="hljs-keyword">const</span> anchor = prevVNode.<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>          el.<span class="hljs-title function_">insertBefore</span>(newVNode.<span class="hljs-property">el</span>, anchor)<br>        &#125;<br><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 更新最大索引</span><br>        lastIndex = j<br>      &#125;<br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="添加新节点">添加新节点</span></h2><p>对于新增节点，在更新时我们应该正确地将它挂载，这主要分为两步：</p>
<ul>
<li>想办法找到新增节点</li>
<li>将新增节点挂载到正确位置</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66c9a05dd9c307b7e91c67db.png"></p>
<p>当遍历到新节点时，我们需要观察我们需要观察节点在新的一组子节点中的位置，获取新子节点组中新节点的前一个节点对应的DOM位置，并移动到该位置后即可。对于非新节点，操作与之前无异。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; newLen; i++) &#123;<br>  <span class="hljs-keyword">const</span> newVNode = newChildren[i]<br><br>  <span class="hljs-comment">// 是否在旧子节点组中找到可复用的节点</span><br>  <span class="hljs-keyword">let</span> found = <span class="hljs-literal">false</span><br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span> ; j &lt; oldLen; j++) &#123;<br>    <span class="hljs-keyword">const</span> oldVNode = oldChildren[j]<br>    <span class="hljs-keyword">if</span> (newVNode === oldVNode) &#123;<br>      <span class="hljs-comment">// 找到相同节点，则先更新后跳出内循环</span><br>      <span class="hljs-title function_">patch</span>(oldVNode, newVNode, el)<br>      <span class="hljs-keyword">if</span> (newVNode.<span class="hljs-property">key</span> === oldVNode.<span class="hljs-property">key</span>) &#123;<br>        found = <span class="hljs-literal">true</span><br>        <span class="hljs-title function_">patch</span>(oldVNode, newVNode, el)<br>        <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>          <span class="hljs-comment">// 需要移动，先获取newVNode的前一个节点prevVNode</span><br>          <span class="hljs-keyword">const</span> prevVNode = newChildren[i - <span class="hljs-number">1</span>]<br>          <span class="hljs-comment">// 如果不存在prevNode说明是新子节点组第一个元素，则不需要移动，作为DOM树的第一个子节点来帮助定位</span><br>          <span class="hljs-keyword">if</span> (prevVNode) &#123;<br>            <span class="hljs-comment">// 获取prevVNode对应真实DOM的下一个兄弟节点作为锚点，插入newVNode</span><br>            <span class="hljs-keyword">const</span> anchor = prevVNode.<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>            el.<span class="hljs-title function_">insertBefore</span>(newVNode.<span class="hljs-property">el</span>, anchor)<br>          &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 更新最大索引</span><br>          lastIndex = j<br>        &#125;<br>        <span class="hljs-keyword">break</span><br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理新节点</span><br>    <span class="hljs-keyword">if</span> (!found) &#123;<br>      <span class="hljs-comment">// 同样获取prevVNode对应真实DOM的下一个兄弟节点作为锚点、</span><br>      <span class="hljs-keyword">const</span> prevVNode = newChildren[i - <span class="hljs-number">1</span>]<br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">anchor</span>: <span class="hljs-title class_">ChildNode</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br>      <span class="hljs-keyword">if</span> (prevVNode) &#123;<br>        anchor = prevVNode.<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 没有prevVNode则说明是第一个节点，用容器元素的第一个子节点作为锚点</span><br>        anchor = el.<span class="hljs-property">firstChild</span><br>      &#125;<br>      <span class="hljs-comment">// 挂载</span><br>      <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, newVNode, el, anchor)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同时调整<code>patch</code>和<code>mountElement</code>以支持<code>anchor</code>参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patch</span>(<span class="hljs-params">..., anchor</span>) &#123;<br>	...<br>    <span class="hljs-comment">// 如果不存在旧虚拟节点，则需要挂载，调用mountElement</span><br>    <span class="hljs-keyword">if</span> (!oldNode) &#123;<br>		<span class="hljs-title function_">mountElement</span>(newNode, container, anchor)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 存在旧虚拟节点，更新</span><br>		<span class="hljs-title function_">patchElement</span>(oldNode, newNode)<br><br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params">..., anchor</span>) &#123;<br>    ...<br>    <span class="hljs-comment">// 将元素添加到挂载点下</span><br>    <span class="hljs-keyword">if</span> (anchor) &#123;<br>    	container.<span class="hljs-title function_">insertBefore</span>(el, anchor)<br>    &#125;<br>    container.<span class="hljs-title function_">appendChild</span>(el)<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="删除旧节点">删除旧节点</span></h2><p>渲染器应该能找到那些需要删除的节点并正确地将其删除。当基本的更新结束时，我们需要遍历旧的一组子节点，然后去新的一组子节<br>点中寻找具有相同 key 值的节点。如果找不到，则说明应该删除该节点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchChild</span>(<span class="hljs-params">...</span>) &#123;<br>  ...<br>  <span class="hljs-comment">// 遍历旧子节点组删除不需要的节点</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; oldLen ; i++) &#123;<br>    <span class="hljs-keyword">const</span> oldVNode = oldChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>    <span class="hljs-comment">// 在新的子节点组中寻找相同key的节点</span><br>    <span class="hljs-keyword">const</span> has = newChildren.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">key</span> === oldVNode.<span class="hljs-property">key</span>)<br><br>    <span class="hljs-comment">// 没找到则卸载</span><br>    <span class="hljs-keyword">if</span> (!has) &#123;<br>      <span class="hljs-title function_">unmount</span>(oldVNode)<br>    &#125;<br>  &#125;<br>  ... <br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>简单diff算法完整代码见：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/CainHappyfish/vue-mvvm-domo/tree/simple-diff-algorithm">CainHappyfish&#x2F;vue-mvvm-domo at simple-diff-algorithm (github.com)</a></p>
</blockquote>
<h1><span id="双端diff算法">双端diff算法</span></h1><p>双端 Diff 算法是一种同时对新旧两组子节点的两个端点进行比较的算法。因此，我们需要四个索引值，分别指向新旧两组子节点的端点。</p>
<p><img src="https://pic.imgdb.cn/item/66c9ca38d9c307b7e9580e8d.png"></p>
<p>在双端比较中，每一轮比较都分为四个步骤：</p>
<ul>
<li>比较旧子节点组的第一个节点和新子节点组的第一个子节点是否相同，相同复用，不相同不做处理</li>
<li>比较旧子节点组的最后一个节点和新子节点组的最后一个子节点是否相同，相同复用，不相同不做处理</li>
<li>比较旧子节点组的第一个节点和新子节点组的最后一个子节点是否相同，相同复用，不相同不做处理</li>
<li>比较新子节点组的第一个节点和旧子节点组的最后一个子节点是否相同，相同复用，不相同不做处理</li>
</ul>
<p>我们按上面图示逐步实现基本的双端diff算法。</p>
<p>节点 p-4 原本是最后一个子节点，在新的顺序中，它变成了第一个子节点，将索引<code>oldEndIndex</code>指向的虚拟节点所对应的真实 DOM 移动到索引<code>oldStartIndex</code>指向的虚拟节点所对应的真实 DOM 前面。</p>
<p><img src="https://pic.imgdb.cn/item/66c9ff22d9c307b7e9a97d6f.png"></p>
<ul>
<li>比较旧的一组子节点中的头部节点 p-1 与新的一组子节点中的头部节点 p-2，由于两者的 key 值不同，不可复用，所以什么都不做。</li>
<li>比较旧的一组子节点中的尾部节点 p-3 与新的一组子节点中的尾部节点 p-3，两者的 key 值相同，可以复用。另外，由于两者都处于尾部，因此不需要对真实 DOM 进行移动操作，只需要打补丁即可。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66ca0295d9c307b7e9acbb15.png"></p>
<ul>
<li>比较旧的一组子节点中的头部节点 p-1 与新的一组子节点中的头部节点 p-2，比较旧的一组子节点中的尾部节点 p-2 与新的一组子节<br>点中的尾部节点 p-1，由于两对节点对应的 key 值均不同，不可复用，因此什么都不做。</li>
<li>比较旧的一组子节点中的头部节点 p-1 与新的一组子节点中的尾部节点 p-1。两者的 key 值相同，可以复用。节点 p-1 原本是头部节点，但在新的顺序中，它变成了尾部节点，需要将节点 p-1 对应的真实 DOM 移动到旧的一组子节点的尾部节点 p-2 所对应的真实 DOM 后面，同时还需要更新相应的索引到下一个位置。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66ca0374d9c307b7e9adb2a2.png"></p>
<p>比较旧的一组子节点中的头部节点 p-2 与新的一组子节点中的头部节点 p-2。发现两者 key 值相同，可以复用。但两者在新旧两组子节点中都是头部节点，因此不需要移动，只需要调用 patch 函数进行打补丁即可。</p>
<p><img src="https://pic.imgdb.cn/item/66ca053cd9c307b7e9b38311.png"></p>
<p>至此，我们就完成了一次双端diff算法，完整代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchKeyedChildren</span>(<span class="hljs-params"><span class="hljs-attr">oldNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-comment">// 获取新旧子节点组的信息</span><br>  <span class="hljs-keyword">const</span> oldChildren = oldNode.<span class="hljs-property">children</span><br>  <span class="hljs-keyword">const</span> newChildren = newNode.<span class="hljs-property">children</span><br>  <span class="hljs-comment">// 索引值</span><br>  <span class="hljs-keyword">let</span> oldStartIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> oldEndIndex = oldChildren.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">let</span> newStartIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> newEndIndex = newChildren.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-comment">// 四个索引节点</span><br>  <span class="hljs-keyword">let</span> oldStartNode = oldChildren[oldStartIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  <span class="hljs-keyword">let</span> oldEndNode = oldChildren[oldEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  <span class="hljs-keyword">let</span> newStartNode = newChildren[newStartIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  <span class="hljs-keyword">let</span> newEndNode = newChildren[newEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br><br>  <span class="hljs-keyword">while</span> (oldStartIndex &lt;= oldEndIndex &amp;&amp; newStartIndex &lt;= newEndIndex) &#123;<br>    <span class="hljs-keyword">if</span> (oldStartNode.<span class="hljs-property">key</span> === newStartNode.<span class="hljs-property">key</span>) &#123;<br>      <span class="hljs-comment">// 仍处于头部，只需要更新</span><br>      <span class="hljs-title function_">patch</span>(oldEndNode, newStartNode, container)<br>      <span class="hljs-comment">// 更新完成后更新索引</span><br>      oldEndNode = oldChildren[++oldStartIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>      newEndNode = newChildren[++newStartIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndNode.<span class="hljs-property">key</span> === newEndNode.<span class="hljs-property">key</span>) &#123;<br>      <span class="hljs-comment">// 仍处于末尾，只需要更新</span><br>      <span class="hljs-title function_">patch</span>(oldEndNode, newStartNode, container)<br>      <span class="hljs-comment">// 更新完成后更新索引</span><br>      oldEndNode = oldChildren[--oldEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>      newEndNode = newChildren[--newEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldStartNode.<span class="hljs-property">key</span> === newEndNode.<span class="hljs-property">key</span>) &#123;<br>      <span class="hljs-comment">// 先更新节点</span><br>      <span class="hljs-title function_">patch</span>(oldEndNode, newStartNode, container)<br>      <span class="hljs-comment">// 移动DOM，将旧头部节点位置移动到旧尾部节点后</span><br>      container.<span class="hljs-title function_">insertBefore</span>(oldStartNode.<span class="hljs-property">el</span>, oldEndNode.<span class="hljs-property">el</span>.<span class="hljs-property">nextSibling</span>)<br><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldEndNode.<span class="hljs-property">key</span> === newStartNode.<span class="hljs-property">key</span>) &#123;<br>      <span class="hljs-comment">// 先更新节点</span><br>      <span class="hljs-title function_">patch</span>(oldEndNode, newStartNode, container)<br>      <span class="hljs-comment">// 移动DOM，将旧尾部节点位置移动到旧头部节点前</span><br>      container.<span class="hljs-title function_">insertBefore</span>(oldStartNode.<span class="hljs-property">el</span>, oldEndNode.<span class="hljs-property">el</span>)<br><br>      <span class="hljs-comment">// 移动完成后更新索引</span><br>      oldEndNode = oldChildren[--oldEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>      newStartNode = newChildren[++newStartIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="非理想状态">非理想状态</span></h2><p><img src="https://pic.imgdb.cn/item/66ca0688d9c307b7e9b74d49.png"></p>
<p>当我们尝试按照双端 Diff 算法的思路进行第一轮比较时，会发现无法命中四个步骤中的任何一步。既然两个头部和两个尾部的四个节点中都没有可复用的节点，那么我们就尝试看看非头部、非尾部的节点能否复用。做法是用新的一组子节点中的头部节点去旧的一组子节点中寻找。找到后，将其移动当前旧的一组子节点的头部节点所对应的真实 DOM 节点之前。</p>
<p><img src="https://pic.imgdb.cn/item/66ca088ad9c307b7e9b9393c.png"></p>
<p>代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 遍历旧子节点组，找到与新头部节点相同的子节点的索引</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> oldChildren !== <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> indexInOld = oldChildren.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> child.<span class="hljs-property">key</span> === newStartNode.<span class="hljs-property">key</span>)<br><br>    <span class="hljs-comment">// 大于0则说明找到对应节点，将其移动到头部</span><br>    <span class="hljs-keyword">if</span> (indexInOld &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">const</span> vnodeToMove = oldChildren[indexInOld]<br>      <span class="hljs-comment">// 更新</span><br>      <span class="hljs-title function_">patch</span>(vnodeToMove, newStartNode, container)<br>      <span class="hljs-comment">// 移动到旧头部节点oldStartNode之前</span><br>      container.<span class="hljs-title function_">insertBefore</span>(vnodeToMove.<span class="hljs-property">el</span>, oldStartNode.<span class="hljs-property">el</span>)<br>      <span class="hljs-comment">// 设置indexInOld处的节点为undefined，更新索引</span><br>      oldChildren[indexInOld].<span class="hljs-property">key</span> = <span class="hljs-literal">undefined</span><br>      <span class="hljs-comment">// 更新newStartIndex到下一个位置</span><br>      newStartNode = newChildren[++newStartIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>完成后，新旧两组子节点以及真实 DOM 节点的状态如图，此时，真实 DOM 的顺序为：p-2、p-1、p-3、p-4。接着，双端 Diff 算法会继续进行：</p>
<p><img src="https://pic.imgdb.cn/item/66ca0acfd9c307b7e9bb9391.png"></p>
<p>当我们遇到<code>undefined</code>节点时，说明该节点已经被处理过了，因此不需要再处理它了，直接跳过即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript">...<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!oldStartNode.<span class="hljs-property">key</span>) &#123;<br>  oldStartNode = oldChildren[++oldStartIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!oldEndNode.<span class="hljs-property">key</span>) &#123;<br>  oldEndNode = oldChildren[--oldEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>&#125;<br>...<br></code></pre></td></tr></table></figure>

<p>四个步骤重合了，进行最后一轮的比较。最后状态如图：</p>
<p><img src="https://pic.imgdb.cn/item/66ca0be9d9c307b7e9bcab80.png"></p>
<h2><span id="添加新元素">添加新元素</span></h2><p>当新子节点组中有旧子节点组不含有的新节点时，我们在旧的一组子节点找不到可复用的节点。</p>
<p>对于处于新子节点组头部的新节点且其他节点顺序与旧子节点组不相同的情况，我们只需将它挂载到当前头部节点之前即可。</p>
<p><img src="https://pic.imgdb.cn/item/66ca0e78d9c307b7e9bf015f.png"></p>
<p>而对于其他节点顺序与旧子节点组相同的情况，我们先运行双端diff算法，得到的结果如下：</p>
<p><img src="https://pic.imgdb.cn/item/66ca0f11d9c307b7e9bf8e30.png"></p>
<p>当这一轮更新完毕后，由于变量<code>oldStartIdx</code>的值大于<code>oldEndIdx</code>的值，满足更新停止的条件，因此更新停止。但节点 p-4 在整个更新过程中被遗漏了，没有得到任何处理。我们添加额外的处理，<code>while</code>循环结束后增加了一个<code>if</code>条件语句，检查四个索引值的情况。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 满足条件则说明遗漏新节点，需要挂载</span><br><span class="hljs-keyword">if</span> (oldEndIndex &lt; oldStartIndex &amp;&amp; newStartIndex &lt; newEndIndex) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newStartIndex; i &lt; newEndIndex; i++) &#123;<br>    <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, newChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>, container, oldStartNode.<span class="hljs-property">el</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="删除旧节点">删除旧节点</span></h2><p><img src="https://pic.imgdb.cn/item/66ca1060d9c307b7e9c0b34f.png"></p>
<p>在新的一组子节点中 p-2 节点已经不存在了。为了搞清楚应该如何处理节点被移除的情况，我们还是按照双端 Diff 算法的思路执行更新，执行结果如下：</p>
<p><img src="https://pic.imgdb.cn/item/66ca1085d9c307b7e9c0d2fd.png"></p>
<p>此时变量<code>newStartIdx</code>的值大于变量<code>newEndIdx</code>的值，满足更新停止的条件，于是更新结束。与添加新元素同理，我们添加<code>if</code>条件处理：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newEndIndex &lt; newStartIndex &amp;&amp; oldStartIndex &lt;= oldEndIndex) &#123;<br>  <span class="hljs-comment">// 满足条件则说明存在不需要的节点，需要卸载</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = oldStartIndex; i &lt; newEndIndex; i++) &#123;<br>    <span class="hljs-title function_">unmount</span>(oldChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此我们完成了双端diff算法。</p>
<blockquote>
<p>双端diff算法完整代码：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/CainHappyfish/vue-mvvm-domo/tree/double-end-diff-algorithm">CainHappyfish&#x2F;vue-mvvm-domo at double-end-diff-algorithm (github.com)</a></p>
</blockquote>
<h1><span id="快速diff算法">快速diff算法</span></h1><p>不同于简单 Diff 算法和双端 Diff 算法，快速 Diff 算法包含预处理步骤，这其实是借鉴了纯文本 Diff 算法的思路。在纯文本 Diff 算法中，存在对两段文本进行预处理的过程。这也称为快捷路径。如果两段文本全等，那么就无须进入核心  Diff 算法的步骤了。除此之外，预处理过程还会处理两段文本相同的前缀和后缀。假设有如下两段文本：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">TEXT1: I use vue for app development<br>TEXT2: I use react for app development<br></code></pre></td></tr></table></figure>

<p>这两段文本的头部和尾部分别有一段相同的内容，对于内容相同的问题，是不需要进行核心 Diff 操作的。真正需要进行 Diff 操作的部分是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TEXT1: vue<br>TEXT2: react<br></code></pre></td></tr></table></figure>

<p>这么做的好处是，在特定情况下我们能够轻松地判断文本的插入和删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TEXT1： I like you<br>TEXT2： I like you too<br></code></pre></td></tr></table></figure>

<p>预处理后的内容为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">TEXT1： <br>TEXT2： too<br></code></pre></td></tr></table></figure>

<p>经过预处理后，TEXT1 的内容为空。这说明 TEXT2 在 TEXT1 的基础上增加了字符串 too。相反，我们还可以将这两段文本的位置互换，再次预处理后：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">TEXT1</span>： too<br><span class="hljs-title class_">TEXT2</span>：<br></code></pre></td></tr></table></figure>

<p>由此可知，TEXT2 是在 TEXT1 的基础上删除了字符串 too，快速 Diff 算法借鉴了纯文本 Diff 算法中预处理的步骤。</p>
<p><img src="https://pic.imgdb.cn/item/66ca9355d9c307b7e95cc94d.png"></p>
<p>两组子节点具有相同的前置节点 p-1，以及相同的后置节点 p-2 和 p-3，对于相同的前置节点和后置节点，由于它们在新旧两组子节点中的相对位置不变，所以我们无须移动它们，但仍然需要在它们之间打补丁。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diff</span>(<span class="hljs-params"><span class="hljs-attr">oldNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> oldChildren = oldNode.<span class="hljs-property">children</span><br>  <span class="hljs-keyword">const</span> newChildren = newNode.<span class="hljs-property">children</span><br><br>  <span class="hljs-comment">// 处理相同前置节点，索引j指向新旧两组子节点的开头</span><br>  <span class="hljs-keyword">let</span> startIndex = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> oldVNode = oldChildren[j] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  <span class="hljs-keyword">let</span> newVNode = newChildren[j] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br><br>  <span class="hljs-comment">// while循环向后遍历，直到不同key值的节点</span><br>  <span class="hljs-keyword">while</span> (oldVNode.<span class="hljs-property">key</span> === newVNode.<span class="hljs-property">key</span>) &#123;<br>    <span class="hljs-comment">// 先更新</span><br>    <span class="hljs-title function_">patch</span>(oldVNode, newVNode, container)<br>    <span class="hljs-comment">// 更新索引j，让其递增</span><br>    startIndex++<br>    oldVNode = oldChildren[j] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>    newVNode = newChildren[j] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  &#125;<br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这一步前置节点更新完成后，目前状态如下：</p>
<p><img src="https://pic.imgdb.cn/item/66ca967fd9c307b7e96202f8.png"></p>
<p>这里需要注意的是，当 while 循环终止时，索引 j 的值为 1。接下来，我们需要处理相同的后置节点。由于新旧两组子节点的数量可能不同，所以我们需要两个索引<code>newEnd</code>和<code> oldEnd</code>，分别指向新旧两组子节点中的最后一个节点。</p>
<p><img src="https://pic.imgdb.cn/item/66ca96ded9c307b7e96257fb.png"></p>
<p>同样的，再开启一个 while 循环，并从后向前遍历这两组子节点，直到遇到 key 值不同的节点为止：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diff</span>(<span class="hljs-params"><span class="hljs-attr">oldNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">newNode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  ...<br>  <br>  <span class="hljs-comment">// 处理相同的后置节点，newEndIndex指向新子节点组的尾部，oldEndIndex指向旧子节点组的尾部</span><br>  <span class="hljs-keyword">let</span> oldEndIndex = oldChildren.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <span class="hljs-keyword">let</span> newEndIndex = newChildren.<span class="hljs-property">length</span> - <span class="hljs-number">1</span><br>  <br>  oldVNode = oldChildren[oldEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  newVNode = newChildren[newEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  <br>  <span class="hljs-comment">// while循环向前遍历，直到不同key值的节点</span><br>  <span class="hljs-keyword">while</span>(oldVNode.<span class="hljs-property">key</span> === newVNode.<span class="hljs-property">key</span>) &#123;<br>    <span class="hljs-comment">// 更新</span><br>    <span class="hljs-title function_">patch</span>(oldVNode, newVNode, container)<br>    <span class="hljs-comment">// 递减索引</span><br>    oldVNode = oldChildren[--oldEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>    newVNode = newChildren[--newEndIndex] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  &#125;<br>  <br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>后置节点更新完成后，状态如下：</p>
<p><img src="https://pic.imgdb.cn/item/66ca9963d9c307b7e964875e.png"></p>
<h2><span id="添加新元素">添加新元素</span></h2><p>当相同的前置节点和后置节点被处理完毕后，旧的一组子节点已经全部被处理了，而在新的一组子节点中，还遗留了一个未被处理的节点 p-4。其实不难发现，节点 p-4 是一个新增节点。此时<code>j &lt;= newEnd &amp;&amp; oldEnd &lt; j</code>，说明在预处理过后，在新的一组子节点中，仍然有未被处理的节点，而这些遗留的节点将被视作新增节点。</p>
<p><img src="https://pic.imgdb.cn/item/66ca9a98d9c307b7e965837e.png"></p>
<p>在新的一组子节点中，索引值处于<code>j</code>和<code>newEnd</code>之间的任何节点都需要作为新的子节点进行挂载。这就要求我们必须找到正确的锚点元素。我们可以发现，节点 p-2 对应的真实 DOM 节点就是挂载操作的锚点元素。（这里用旧子节点组<code>j</code>处的元素当锚点应该也是可以的）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/* 处理新增节点 */</span><br><span class="hljs-keyword">if</span> (startIndex &gt; oldEndIndex &amp;&amp; startIndex &lt;= newEndIndex) &#123;<br>    <span class="hljs-comment">// 获取锚点</span><br>    <span class="hljs-keyword">const</span> anchorIndex = newEndIndex + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">const</span> anchor = anchorIndex &lt; newEndIndex ? newChildren[anchorIndex].<span class="hljs-property">el</span> : <span class="hljs-literal">null</span><br>    <span class="hljs-comment">// 挂载每个新增节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= newEndIndex ; i++) &#123;<br>      <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, newChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>, container, anchor)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="删除旧节点">删除旧节点</span></h2><p><img src="https://pic.imgdb.cn/item/66ca9e38d9c307b7e968c33c.png"></p>
<p>进行预处理，处理后的状态如图：</p>
<p><img src="https://pic.imgdb.cn/item/66ca9e60d9c307b7e968f172.png"></p>
<p>当相同的前置节点和后置节点全部被处理完毕后，新的一组子节点已经全部被处理完毕了，而旧的一组子节点中遗留了一个节点 p-2 。这说明，应该卸载节点 p-2 。实际上，遗留的节点可能有多个。</p>
<p><img src="https://pic.imgdb.cn/item/66ca9f05d9c307b7e96ab976.png"></p>
<p>索引<code>j</code>和索引<code>oldEnd</code>之间的任何节点都应该被卸载，与新增元素实现类似：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (startIndex &gt; newEndIndex &amp;&amp; startIndex &lt;= oldEndIndex) &#123;<br>    <span class="hljs-comment">/* 删除节点 */</span><br>    <span class="hljs-comment">// 删除不需要的节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= oldEndIndex ; i++) &#123;<br>      <span class="hljs-title function_">unmount</span>(oldChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="移动dom节点">移动DOM节点</span></h2><p><img data-fancybox="gallery" data-sizes="auto" data-src="https://pic.imgdb.cn/item/66caca24d9c307b7e99fca33.png" alt=" " class="lazyload"></p>
<p>与旧的一组子节点相比，新的一组子节点多出了一个新节点 p-7，少了一个节点 p-6。经过预处理后，无论是新的一组子节点，还是旧一组子节点，都有部分节点未经处理。接下来我们的任务就是，判断哪些节点需要移动，以及应该如何移动。在这种非理想的情况下，当相同的前置节点和后置节点被处理完毕后，索引<code> j</code>、<code>newEnd</code>和<code>oldEnd</code>不满足下面两个条件中的任何一个：</p>
<ul>
<li><code>j &gt; oldEnd &amp;&amp; j &lt;= newEnd</code></li>
<li><code>j &gt; newEnd &amp;&amp; j &lt;= oldEnd</code></li>
</ul>
<p>我们需要构造一个数组<code> source</code>，它的长度等于新的一组子节点在经过预处理之后剩余未处理节点的数量，并且<code>source</code>中每个元素的初始值都是 -1：</p>
<p><img src="https://pic.imgdb.cn/item/66cb34a1d9c307b7e93140e2.png"><code>source</code>数组将用来存储新的一组子节点中的节点在旧的一组子节点中的位置索引，后面将会使用它计算出一个最长递增子序列，并用于辅助完成 DOM 移动的操作。source &#96;数组存储的是新子节点在旧的一组子节点中的位置索引，旧子节点组中没有新节点，于是保留原来的-1：</p>
<p><img src="https://pic.imgdb.cn/item/66cbf7ffd9c307b7e906938b.png"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 构造source数组记录未处理的节点数</span><br>    <span class="hljs-keyword">const</span> source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(newEndIndex - startIndex + <span class="hljs-number">1</span>)<br>    source.<span class="hljs-title function_">fill</span>(-<span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// 遍历旧子节点组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= oldEndIndex; i++) &#123;<br>      <span class="hljs-keyword">const</span> oldVNode = oldChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>      <span class="hljs-comment">// 遍历新子节点组</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = startIndex ; j &lt;= newEndIndex ; i++) &#123;<br>        <span class="hljs-keyword">const</span> newVNode = newChildren[j] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>        <span class="hljs-comment">// 找到可复用节点</span><br>        <span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">key</span> === newVNode.<span class="hljs-property">key</span>) &#123;<br>          <span class="hljs-comment">// 更新</span><br>          <span class="hljs-title function_">patch</span>(oldVNode, newVNode, container)<br>          <span class="hljs-comment">// 填充source</span><br>          source[j - startIndex] = i<br>        &#125;<br>      &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码的时间复杂度为平方级别，处理较多节点时会带来性能问题，出于优化的目的，我们可以为新的一组子节点构建一张索引表，用来存储节点的 key 和节点位置索引之间的映射。</p>
<p><img src="https://pic.imgdb.cn/item/66cc2dacd9c307b7e9464c87.png"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 构建索引表</span><br><span class="hljs-keyword">const</span> keyIndex = &#123;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= newEndIndex; i++) &#123;<br>  <span class="hljs-keyword">const</span> index = (newChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>).<span class="hljs-property">key</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span><br>  keyIndex[index] = i<br>&#125;<br><br><span class="hljs-comment">// 遍历旧子节点组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= oldEndIndex; i++) &#123;<br>  <span class="hljs-keyword">const</span> oldVNode = oldChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  <span class="hljs-comment">// 通过索引表快速找到有相同key的新子节点</span><br>  <span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">key</span>) &#123;<br>    <span class="hljs-keyword">const</span> j = keyIndex[oldVNode.<span class="hljs-property">key</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>]<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> j !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>      newVNode = newChildren[j] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>      <span class="hljs-comment">// 更新</span><br>      <span class="hljs-title function_">patch</span>(oldVNode, newVNode, container)<br>      <span class="hljs-comment">// 填充source</span><br>      source[j - startIndex] = i<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 未找到则删除节点</span><br>      <span class="hljs-title function_">unmount</span>(oldVNode)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;key doesn&#x27;t exist.&quot;</span>)<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述流程执行完毕后，source 数组已经填充完毕了，接下来我们判断节点是否需要移动，方法与简单diff算法类似。除此之外，我们还需要一个数量标识，代表已经更新过的节点数量。我们知道，已经更新过的节点数量应该小于新的一组子节点中需要更新的节点数量。一旦前者超过后者，则说明有多余的节点，我们应该将它们卸载：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 构造source数组记录未处理的节点数</span><br><span class="hljs-keyword">const</span> count = newEndIndex - startIndex + <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> source = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(count)<br>source.<span class="hljs-title function_">fill</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-comment">// 是否需要移动</span><br><span class="hljs-keyword">let</span> moved = <span class="hljs-literal">false</span><br><span class="hljs-comment">// 当前最大索引值</span><br><span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 构建索引表</span><br><span class="hljs-keyword">const</span> keyIndex = &#123;&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= newEndIndex; i++) &#123;<br>  <span class="hljs-keyword">const</span> index = (newChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>).<span class="hljs-property">key</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span><br>  keyIndex[index] = i<br>&#125;<br><br><span class="hljs-comment">// 记录更新过的节点数</span><br><span class="hljs-keyword">let</span> patched = <span class="hljs-number">0</span><br><span class="hljs-comment">// 遍历旧子节点组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = startIndex; i &lt;= oldEndIndex; i++) &#123;<br>  <span class="hljs-keyword">const</span> oldVNode = oldChildren[i] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>  <span class="hljs-comment">// 通过索引表快速找到有相同key的新子节点</span><br>  <span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">key</span> &amp;&amp; patched &lt;= count) &#123;<br>    <span class="hljs-keyword">const</span> j = keyIndex[oldVNode.<span class="hljs-property">key</span>]<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> j !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>      newVNode = newChildren[j] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>      <span class="hljs-comment">// 更新</span><br>      <span class="hljs-title function_">patch</span>(oldVNode, newVNode, container)<br>      patched++<br>      <span class="hljs-comment">// 填充source</span><br>      source[j - startIndex] = i<br><br>      <span class="hljs-comment">// 判断是否需要移动</span><br>      <span class="hljs-keyword">if</span> (j &lt; lastIndex) &#123;<br>        moved = <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        lastIndex = j<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 未找到则删除节点</span><br>      <span class="hljs-title function_">unmount</span>(oldVNode)<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">unmount</span>(oldVNode)<br><br>    <span class="hljs-keyword">if</span> (oldVNode.<span class="hljs-property">key</span>) <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;key doesn&#x27;t exist.&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那具体应该如何移动节点呢，我们根据<code>source</code>数组计算出一个最长递增子序列，用于 DOM 移动操作，下面是Vue的实现，采用了二分查找，返回最长递增子序列在<code>source</code>数组中对应的索引值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSequence</span>(<span class="hljs-params"><span class="hljs-attr">arr</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;</span>) &#123;<br>  <span class="hljs-keyword">const</span> predecessorIndices = arr.<span class="hljs-title function_">slice</span>(); <span class="hljs-comment">// 用于记录序列中每个元素的索引值，比如[3,11,24]对应[0,1,2]</span><br>  <span class="hljs-keyword">const</span> sequenceIndices = [<span class="hljs-number">0</span>]; <span class="hljs-comment">// 用于存储最长递增子序列的元素索引</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">j</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">left</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">right</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">middle</span>: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">const</span> length = arr.<span class="hljs-property">length</span>;<br><br>  <span class="hljs-comment">// 遍历数组中的每个元素</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-keyword">const</span> currentElement = arr[i];<br><br>    <span class="hljs-keyword">if</span> (currentElement !== <span class="hljs-number">0</span>) &#123;<br>      j = sequenceIndices[sequenceIndices.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br><br>      <span class="hljs-comment">// 如果当前元素大于序列中的最后一个元素</span><br>      <span class="hljs-keyword">if</span> (arr[j] &lt; currentElement) &#123;<br>        predecessorIndices[i] = j; <span class="hljs-comment">// 记录前一个元素的索引</span><br>        sequenceIndices.<span class="hljs-title function_">push</span>(i); <span class="hljs-comment">// 将当前元素的索引添加到序列中</span><br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 使用二分查找确定当前元素在序列中的插入位置</span><br>      left = <span class="hljs-number">0</span>;<br>      right = sequenceIndices.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        middle = ((left + right) / <span class="hljs-number">2</span>) | <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (arr[sequenceIndices[middle]] &lt; currentElement) &#123;<br>          left = middle + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          right = middle;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 如果需要，替换序列中的元素</span><br>      <span class="hljs-keyword">if</span> (currentElement &lt; arr[sequenceIndices[left]]) &#123;<br>        <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) &#123;<br>          predecessorIndices[i] = sequenceIndices[left - <span class="hljs-number">1</span>];<br>        &#125;<br>        sequenceIndices[left] = i;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 根据前驱索引重建最终递增子序列</span><br>  left = sequenceIndices.<span class="hljs-property">length</span>;<br>  right = sequenceIndices[left - <span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">while</span> (left-- &gt; <span class="hljs-number">0</span>) &#123;<br>    sequenceIndices[left] = right;<br>    right = predecessorIndices[right];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> sequenceIndices;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有了最长递增子序列的索引信息后，下一步要重新对节点进行编号。最长递增子序列 seq 拥有一个非常重要的意义。以上例来说，子序列<code>seq</code>的值为 [0, 1]，它的含义是：在新的一组子节点中，重新编号后索引值为 0 和 1 的这两个节点在更新前后顺序没有发生变化。为了完成节点的移动，我们还需要创建两个索引值<code>i</code>和<code>s</code>，分别用于指向新的一组子节点中的最后一个节点和最长递增子序列中的最后一个元素：</p>
<p><img src="https://pic.imgdb.cn/item/66cc4ab0d9c307b7e96df621.png"></p>
<p>逐个访问新的一组子节点中的节点，如果节点的索引<code>i</code>不等于 seq[s] 的值，则说明该节点对应的真实 DOM 需要移动，否<br>则说明当前访问的节点不需要移动：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newEnd; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>       <span class="hljs-comment">// 均为新节点，挂载</span><br>       <span class="hljs-comment">// 在新子节点组中的绝对位置索引，并获取对应的节点</span><br>       <span class="hljs-keyword">const</span> pos = i + startIndex<br>       <span class="hljs-keyword">const</span> newVNode = newChildren[pos] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>       <span class="hljs-comment">// 该节点的下一个节点的位置索引</span><br>       <span class="hljs-keyword">const</span> nextPos = pos + <span class="hljs-number">1</span><br>       <span class="hljs-comment">// 获取锚点</span><br>       <span class="hljs-keyword">const</span> anchor = nextPos &lt; newChildren.<span class="hljs-property">length</span><br>       ? (newChildren[nextPos] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>).<span class="hljs-property">el</span><br>       : <span class="hljs-literal">null</span><br>       <span class="hljs-keyword">if</span> (source[i] === -<span class="hljs-number">1</span>) &#123;<br>         <span class="hljs-comment">// 挂载</span><br>         <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, newVNode, container, anchor)<br>       &#125;<br>       <span class="hljs-keyword">if</span> (i !== seq[seqEnd]) &#123;<br>         <span class="hljs-comment">// 如果节点的索引 i 不等于 seq[seqEnd] 的值，说明该节点需要移动</span><br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-comment">// 否则不需要移动， seqEnd指向下一个位置</span><br>         seqEnd--<br>       &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>

<p>循环执行一次后，结果如下：</p>
<p><img src="https://pic.imgdb.cn/item/66cc45e8d9c307b7e9665d44.png"></p>
<p>接下来我们发现节点 p-2 需要移动：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = newEnd; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>    <span class="hljs-comment">// 均为新节点，挂载</span><br>    <span class="hljs-comment">// 在新子节点组中的绝对位置索引，并获取对应的节点</span><br>    <span class="hljs-keyword">const</span> pos = i + startIndex<br>    <span class="hljs-keyword">const</span> newVNode = newChildren[pos] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span><br>    <span class="hljs-comment">// 该节点的下一个节点的位置索引</span><br>    <span class="hljs-keyword">const</span> nextPos = pos + <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 获取锚点</span><br>    <span class="hljs-keyword">const</span> anchor = nextPos &lt; newChildren.<span class="hljs-property">length</span><br>    ? (newChildren[nextPos] <span class="hljs-keyword">as</span> <span class="hljs-title class_">VNode</span>).<span class="hljs-property">el</span><br>    : <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">if</span> (source[i] === -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// 挂载</span><br>      <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, newVNode, container, anchor)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i !== seq[seqEnd]) &#123;<br>      <span class="hljs-comment">// 如果节点的索引 i 不等于 seq[seqEnd] 的值，说明该节点需要移动</span><br>      container.<span class="hljs-title function_">insertBefore</span>(newVNode.<span class="hljs-property">el</span>, anchor)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则不需要移动， seqEnd指向下一个位置</span><br>      seqEnd--<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该轮循环结束，移动完成，当前状态如下：</p>
<p><img src="https://pic.imgdb.cn/item/66cc555fd9c307b7e97b9265.png">此时我们不难发现 p-3 和 p-4 都不需要移动，且不是新的节点，在更新完成之后，循环将会停止，更新完成。</p>
<h1><span id="总结">总结</span></h1>
	</article>

	 
    <div class="kira-post-copyright">
        <strong>Author：</strong>破酥 | C4iN<br>
        <strong>Link：</strong><a href="https://c4in1.github.io/2024/08/18/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM-2/" title="https:&#x2F;&#x2F;c4in1.github.io&#x2F;2024&#x2F;08&#x2F;18&#x2F;MVVM&#x2F;实现一个简单的MVVM-2&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;c4in1.github.io&#x2F;2024&#x2F;08&#x2F;18&#x2F;MVVM&#x2F;实现一个简单的MVVM-2&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			      
			<!-- 先找到与当前文字相同的目录 -->
			         
			<!-- 在找到当前文章所在的 index -->
			        
			<!-- 上一篇文章 -->
			<div class="old">
				<span>上一章</span>
				<a href="/2024/08/09/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84mvvm-1/"> 实现一个简单的MVVM-1</a>
			</div>
			                          
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/MVVM/">MVVM</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/MVVM/" rel="tag">MVVM</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/Vue/" rel="tag">Vue</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	<div class="giscus"></div>
  
    <script src="https://giscus.app/client.js"
      data-repo="C4in1/BlogGitTalk"
      data-repo-id="R_kgDOMgx61Q"
      data-category="General"
      data-category-id="DIC_kwDOMgx61c4Chec4"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="light"
      data-lang="en"
      data-loading="lazy"
      crossorigin="anonymous"
      async  
    ></script>
  

	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
