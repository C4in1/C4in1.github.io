<!DOCTYPE html>
<html 
	lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> 实现一个简单的MVVM-4 -  C4iN&#39;s Caprice</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="https://pic.imgdb.cn/item/6693875ad9c307b7e98b4288.gif"
			type="image/gif"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('https://pic.imgdb.cn/item/66b458ffd9c307b7e9aadb03.png')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="C4iN&#39;s Caprice">
        <img
			src="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png"
			alt="破酥 | C4iN"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png" title="破酥 | C4iN">
			<img
				src="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png"
				alt="破酥 | C4iN"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>13</div>
		<div><span>标签</span>13</div>
		<div><span>分类</span>6</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/friends"
			title="我的朋友"
		>
			<i
				class="kirafont
					
						icon-team
					"
			></i>
			<div class="kira-list-item-content">
				我的朋友
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2405544030&website=www.oicqzone.com"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/CainHappyfish/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/MVVM/">
              MVVM
            </a>
            <span class="category-list-count">5</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/TypeScript/">
              TypeScript
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/Vue/">
              Vue
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/project/">
              project
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/vitepress/">
              vitepress
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/项目构建/">
              项目构建
            </a>
            <span class="category-list-count">2</span>
          </li>
        
      </ul>
    </div>
  </div>

		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/MVVM/" style="font-size: 16px;">MVVM</a> <a href="/tags/TypeScript/" style="font-size: 18px;">TypeScript</a> <a href="/tags/Typescript/" style="font-size: 10px;">Typescript</a> <a href="/tags/Vitepress/" style="font-size: 12px;">Vitepress</a> <a href="/tags/Vue/" style="font-size: 16px;">Vue</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/theme-censored/" style="font-size: 12px;">theme-censored</a> <a href="/tags/vue3/" style="font-size: 14px;">vue3</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E7%97%9B%E8%8B%A6%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" style="font-size: 12px;">痛苦的配置问题</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83/" style="font-size: 10px;">项目规范</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			Archive
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">13</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2024
		<a href="/">破酥 | C4iN</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><div><span id="busuanzi_container_site_uv">共接待访客<span id="busuanzi_value_site_uv"></span>位</span></div>
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div class="kira-post-cover">
			<img
				data-src="https://pic.imgdb.cn/item/66b47385d9c307b7e9d0b377.png"
				data-sizes="auto"
				alt="实现一个简单的MVVM-4"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>实现一个简单的MVVM-4</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2024年08月30日</a>
			<a><i class="kirafont icon-edit-fill"></i>15.3k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 71 分钟</a>
		</div>
		<p>这部分讲MVVM中编译器的实现。</p>
<span id="more"></span>

<p><del>又要被编译原理折磨了（悲</del></p>
<p>作为前端，我们应用编译技术的场景通常是：表格、报表中的自定义公式计算器，设计一种领域特定语言（DSL）等。</p>
<h1><span id="编译器">编译器</span></h1><p>编译器其实只是一段程序，它用来将“一种语言 A”翻译成“另外一种语言 B”。其中，语言 A 通常叫作源代码（source code），语言 B 通常叫作目标代码（object code 或 target code）。编译器将源代码翻译为目标代码的过程叫作编译（compile）。以下是教科书式完整编译过程：</p>
<p><img src="https://pic.imgdb.cn/item/66d3c757d9c307b7e9e078df.png"></p>
<h2><span id="dsl模板编译">DSL模板编译</span></h2><p>对于 Vue.js 模板编译器来说，源代码就是组件的模板，而目标代码是能够在浏览器平台上运行的 JavaScript 代码，或其他拥有 JavaScript 运行时的平台代码，模板编译器的目标代码其实就是渲染函数：</p>
<p><img src="https://pic.imgdb.cn/item/66d3c7d7d9c307b7e9e0c61b.png"></p>
<p>模板编译器会首先对模板进行词法分析和语法分析，得到模板 AST。接着，将模板 AST 转换（transform）成 JavaScript AST。最后，根据 JavaScript AST 生成 JavaScript 代码，即渲染函数代码。</p>
<p><img src="https://pic.imgdb.cn/item/66d3c85bd9c307b7e9e11c20.png"></p>
<p>比如我们有这么一段模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div&gt;<br>    &lt;h1 v-if=&quot;ok&quot;&gt;<br>        Template<br>    &lt;/h1&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>将会被编译成如下的AST：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> ast = &#123;<br>    <span class="hljs-comment">// 逻辑根节点</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Root&#x27;</span>,<br>    <span class="hljs-attr">children</span>: [<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Element&#x27;</span>,<br>        <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>        <span class="hljs-attr">children</span>: [<br>            &#123;<br>				<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Element&#x27;</span>,<br>        		<span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;h1&#x27;</span>,<br>        		<span class="hljs-attr">props</span>: [<br>        			<span class="hljs-comment">// v-if 节点</span><br>        			&#123;<br>        				<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Directive&#x27;</span>,<br>        				<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;if&#x27;</span><br>        				<span class="hljs-comment">// 表达式节点</span><br>        				<span class="hljs-attr">exp</span>: &#123;<br>							<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Expression&#x27;</span>,<br>        					<span class="hljs-attr">conten</span>: <span class="hljs-string">&#x27;ok&#x27;</span><br>                        &#125;<br>        			&#125;<br>                ]<br>            &#125;<br>        ]<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>模板 AST 具有与模板同构的嵌套结构。每一棵 AST 都有一个逻辑上的根节点，其类型为 Root。模板中真正的根节点则作为 Root 节点的 children 存在。</p>
<ul>
<li>不同类型的节点是通过节点的 type 属性进行区分的。例如标签节点的 type 值为 ‘Element’。</li>
<li>标签节点的子节点存储在其 children 数组中。</li>
<li>标签节点的属性节点和指令节点会存储在 props 数组中。</li>
<li>不同类型的节点会使用不同的对象属性进行描述。例如指令节点拥有 name 属性，用来表达指令的名称，而表达式节点拥有 content 属性，用来描述表达式的内容。</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66d3cbeed9c307b7e9e39a4d.png"></p>
<p><code>parse</code>函数接收字符串模板作为参数，并将解析后得到的 AST 作为返回值返回。</p>
<p>有了模板 AST 后，我们就可以对其进行语义分析，并对模板 AST进行转换了。接着，我们还需要将模板 AST 转换为 JavaScript AST。因为 Vue.js 模板编译器的最终目标是生成渲染函数，而渲染函数本质上是 JavaScript 代码，所以我们需要将模板 AST 转换成用于描述渲染函数的 JavaScript AST。</p>
<p><img src="https://pic.imgdb.cn/item/66d3cc8dd9c307b7e9e412b3.png"></p>
<p>有了 JavaScript AST 后，我们就可以根据它生成渲染函数了，<code>generate</code>函数会将渲染函数的代码以字符<br>串的形式返回，并存储在<code>code</code>常量中。</p>
<p><img src="https://pic.imgdb.cn/item/66d3ccc1d9c307b7e9e43b21.png"></p>
<p>下面是完整流程：</p>
<p><img src="https://pic.imgdb.cn/item/66d3ccd2d9c307b7e9e4466e.png"></p>
<h2><span id="parse实现原理与状态机"><code>parse</code>实现原理与状态机</span></h2><p>解析器的入参是字符串模板，解析器会逐个读取字符串模板中的字符，并根据一定的规则将整个字符串切割为一个个 Token。下面是这个过程的有限状态自动机，有的圆圈是单线的，而有的圆圈是双线的。双线代表此时状态机是一个合法的 Token：</p>
<p><img src="https://pic.imgdb.cn/item/66d3ce9fd9c307b7e9e5a4e7.png"></p>
<p>对于模板<code>&lt;div&gt;Hello&lt;/div&gt;</code>，有如下过程：</p>
<ul>
<li>状态机处于<strong>初始状态1</strong></li>
<li><strong>初始状态1</strong>读取<code>&lt;</code>，进入标签<strong>开始状态2</strong></li>
<li><strong>标签开始状态2</strong>读取<code>div</code>，由于是字母，直到读取到<code>&gt;</code>前都处于<strong>标签名称状态3</strong></li>
<li><strong>标签名称状态3</strong>读取<code>&gt;</code>，回到<strong>初始状态1</strong></li>
<li><strong>初始状态1</strong>读取到文本内容<code>Hello</code>，直到读取<code>&lt;</code>前都处于<strong>文本状态4</strong>，并记录在文本状态 4下产生的文本内容，</li>
<li><strong>文本状态4</strong>读取<code>&lt;</code>，进入<strong>标签开始状态2</strong></li>
<li><strong>标签开始状态2</strong>读取<code>/</code>，进入<strong>结束标签状态5</strong></li>
<li><strong>结束标签状态5</strong>读取<code>div</code>，直到读取到<code>&gt;</code>前都处于<strong>结束标签名称状态6</strong></li>
<li><strong>结束标签名称状态6</strong>读取<code>&gt;</code>，回到<strong>初始状态1</strong>，分析结束，并记录在<strong>结束标签名称状态 6</strong>下生成的结束标签名称。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">tokenize</span>(<span class="hljs-params"><span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span></span>) &#123;<br><br>  <span class="hljs-comment">// 状态机当前状态</span><br>  <span class="hljs-keyword">let</span> currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">initial</span><br>  <span class="hljs-comment">// 缓存字符</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">chars</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt; = []<br>  <span class="hljs-comment">// 存储生成 Token</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">tokens</span>: <span class="hljs-title class_">Array</span>&lt;token&gt; = []<br><br>  <span class="hljs-comment">// 使用while循环开启自动机</span><br>  <span class="hljs-keyword">while</span> (str) &#123;<br>    <span class="hljs-comment">// 查看第一个字符</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">char</span>: <span class="hljs-built_in">string</span> = str[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment">// 状态匹配</span><br>    <span class="hljs-keyword">switch</span> (currentState) &#123;<br>      <span class="hljs-comment">/* 初始状态 */</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">State</span>.<span class="hljs-property">initial</span>:<br>        <span class="hljs-comment">// 进入标签开始状态</span><br>        <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>          currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">tagStart</span><br>          <span class="hljs-comment">// 指向下一个字符</span><br>          str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAlpha</span>(char)) &#123;<br>          <span class="hljs-comment">// 进入文本状态</span><br><br>          currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">text</span><br>          <span class="hljs-comment">// 缓存当前字母</span><br>          chars.<span class="hljs-title function_">push</span>(char)<br>          <span class="hljs-comment">// 指向下一个字符</span><br>          str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br><br>        &#125;<br>        <span class="hljs-keyword">break</span><br><br>      <span class="hljs-comment">/* 标签开始状态 */</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">State</span>.<span class="hljs-property">tagStart</span>:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAlpha</span>(char)) &#123;<br>          <span class="hljs-comment">// 进入标签名称状态</span><br><br>          currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">tagName</span><br>          <span class="hljs-comment">// 缓存当前字母</span><br>          chars.<span class="hljs-title function_">push</span>(char)<br>          <span class="hljs-comment">// 指向下一个字符</span><br>          str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>          <span class="hljs-comment">// 进入结束标签状态</span><br><br>          currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">tagEnd</span><br>          <span class="hljs-comment">// 指向下一个字符</span><br>          str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br>        &#125;<br>        <span class="hljs-keyword">break</span><br><br>      <span class="hljs-comment">/* 标签名称状态 */</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">State</span>.<span class="hljs-property">tagName</span>:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAlpha</span>(char)) &#123;<br>          <span class="hljs-comment">// 缓存当前字母</span><br>          chars.<span class="hljs-title function_">push</span>(char)<br>          <span class="hljs-comment">// 指向下一个字符</span><br>          str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&#x27;&gt;&#x27;</span>) &#123;<br>          <span class="hljs-comment">// 切换初始状态</span><br><br>          currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">initial</span><br>          <span class="hljs-comment">// 创建标签token，存储到tokens中</span><br>          tokens.<span class="hljs-title function_">push</span>(&#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;tag&quot;</span>,<br>            <span class="hljs-attr">name</span>: chars.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>          &#125;)<br>          <span class="hljs-comment">// 重置缓存</span><br>          chars.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>          <span class="hljs-comment">// 指向下一个字符</span><br>          str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br>        &#125;<br>        <span class="hljs-keyword">break</span><br><br>      <span class="hljs-comment">/* 文本状态 */</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-title class_">State</span>.<span class="hljs-property">text</span>:<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAlpha</span>(char)) &#123;<br>          <br>          chars.<span class="hljs-title function_">push</span>(char)<br>          str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br>          <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>          <span class="hljs-comment">// 进入标签开始状态</span><br>          currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">tagStart</span><br>          <span class="hljs-comment">// 创建文本token</span><br>          tokens.<span class="hljs-title function_">push</span>(&#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;text&quot;</span>,<br>            <span class="hljs-attr">content</span>: chars.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>          &#125;)<br>          <span class="hljs-comment">// 重置缓存</span><br>          chars.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>          <span class="hljs-comment">// 指向下一个字符</span><br>          str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br>        &#125;<br>        <span class="hljs-keyword">break</span><br><br>      <span class="hljs-comment">/* 标签结束状态 */</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-title class_">State</span>.<span class="hljs-property">tagEnd</span>:<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAlpha</span>(char)) &#123;<br>            currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">tagEndName</span><br>            <span class="hljs-comment">// 缓存当前字母</span><br>            chars.<span class="hljs-title function_">push</span>(char)<br>            <span class="hljs-comment">// 指向下一个字符</span><br>            str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br>            <br>          &#125;<br>          <span class="hljs-keyword">break</span><br><br>      <span class="hljs-comment">/* 标签结束名称状态 */</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-title class_">State</span>.<span class="hljs-property">tagEndName</span>:<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isAlpha</span>(char)) &#123;<br><br>            chars.<span class="hljs-title function_">push</span>(char)<br>            str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br><br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (char === <span class="hljs-string">&#x27;&gt;&#x27;</span>) &#123;<br>            <span class="hljs-comment">// 切换初始状态</span><br>            currentState = <span class="hljs-title class_">State</span>.<span class="hljs-property">initial</span><br>            <span class="hljs-comment">// 保存结束标签token</span><br>            tokens.<span class="hljs-title function_">push</span>(&#123;<br>              <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;tagEnd&#x27;</span>,<br>              <span class="hljs-attr">name</span>: chars.<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>            &#125;)<br>            <span class="hljs-comment">// 重置缓存</span><br>            chars.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br>            <span class="hljs-comment">// 指向下一个字符</span><br>            str = str.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>)<br>            <br>          &#125;<br><br>        <br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> tokens<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码是最基础的实现方式，易于理解，后续会继续优化这段代码。我们可以通过正则表达式来精简 tokenize 函数的代码。</p>
<h2><span id="构造ast">构造AST</span></h2><p>HTML 是一种标记语言，它的格式非常固定，标签元素之间天然嵌套，形成父子关系。因此，一棵用于描述 HTML 的 AST 将拥有与 HTML 标签非常相似的树型结构。</p>
<p><img src="https://pic.imgdb.cn/item/66d50bc1d9c307b7e954ebe8.png"></p>
<p>根据 Token 列表构建 AST 的过程，其实就是对 Token 列表进行扫描的过程。从第一个 Token 开始，顺序地扫描整个 Token 列表，直到列表中的所有 Token 处理完毕。在这个过程中，我们需要维护一个栈<code> elementStack</code>，这个栈将用于维护元素间的父子关系。</p>
<ul>
<li>每遇到一个开始标签节点，我们就构造一个<code>Element</code>类型的 AST 节点，并将其压入栈中。</li>
<li>类似地，每当遇到一个结束标签节点，我们就将当前栈顶的节点弹出。</li>
</ul>
<p>这样，栈顶的节点将始终充当父节点的角色。扫描过程中遇到的所有节点，都会作为当前栈顶节点的子节点，并添加到栈顶节点的<code>children</code>属性下。</p>
<p><img src="https://pic.imgdb.cn/item/66d50c00d9c307b7e955159d.png"></p>
<p>结束状态：</p>
<p><img src="https://pic.imgdb.cn/item/66d50d08d9c307b7e955c1a8.png"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">templateStr</span>) &#123;<br>  <span class="hljs-comment">// 获取模板对应token</span><br>  <span class="hljs-keyword">const</span> tokens = <span class="hljs-title function_">tokenize</span>(templateStr)<br>  <span class="hljs-comment">// 创建Root节点</span><br>  <span class="hljs-keyword">const</span> root = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Root&#x27;</span>,<br>    <span class="hljs-attr">children</span>: []<br>  &#125;<br><br>  <span class="hljs-comment">// 创建 elementStack 栈</span><br>  <span class="hljs-keyword">const</span> elementStack = [root]<br><br>  <span class="hljs-comment">// 循环扫描 tokens</span><br>  <span class="hljs-keyword">while</span> (tokens.<span class="hljs-property">length</span>) &#123;<br>    <span class="hljs-comment">// 获取当前栈顶节点作为父节点 parent</span><br>    <span class="hljs-keyword">const</span> parent = elementStack[elementStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>] <span class="hljs-keyword">as</span> <span class="hljs-title class_">AstNode</span><br>    <span class="hljs-comment">// 获取当前 token</span><br>    <span class="hljs-keyword">const</span> token = tokens[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">switch</span> (token.<span class="hljs-property">type</span>) &#123;<br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tag&#x27;</span>:<br>        <span class="hljs-comment">// 如果token是开始标签，则创建 Element 类型的AST节点</span><br>        <span class="hljs-keyword">const</span> elementNode = &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Element&#x27;</span>,<br>          <span class="hljs-attr">tag</span>: token.<span class="hljs-property">name</span>,<br>          <span class="hljs-attr">children</span>: []<br>        &#125;<br>        <span class="hljs-comment">// 添加到父节点的 children</span><br>        parent.<span class="hljs-property">children</span>?.<span class="hljs-title function_">push</span>(elementNode)<br>        <span class="hljs-comment">// 压栈</span><br>        elementStack.<span class="hljs-title function_">push</span>(elementNode)<br>        <span class="hljs-keyword">break</span><br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;text&#x27;</span>:<br>        <span class="hljs-comment">// 如果token是文本节点，则创建 Element 类型的AST节点</span><br>        <span class="hljs-keyword">const</span> textNode = &#123;<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Text&#x27;</span>,<br>          <span class="hljs-attr">content</span>: token.<span class="hljs-property">content</span><br>        &#125;<br>        <span class="hljs-comment">// 添加到父节点的 children</span><br>        parent.<span class="hljs-property">children</span>?.<span class="hljs-title function_">push</span>(textNode)<br>        <span class="hljs-keyword">break</span><br><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;tagEnd&#x27;</span>:<br>        <span class="hljs-comment">// 结束标签则弹出栈顶元素</span><br>        elementStack.<span class="hljs-title function_">pop</span>()<br>        <span class="hljs-keyword">break</span><br>    &#125;<br><br>    <span class="hljs-comment">// 移除处理过的 token</span><br>    tokens.<span class="hljs-title function_">shift</span>()<br><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> root<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="ast-的转换与插件化架构">AST 的转换与插件化架构</span></h2><p>所谓 AST 的转换，指的是对 AST 进行一系列操作，将其转换为新的 AST 的过程。新的 AST 可以是原语言或原 DSL 的描述，也可以是其他语言或其他 DSL 的描述。转换后的 AST 可以用于代码生成。这其实就是 Vue 的模板编译器将模板编译为渲染函数的过程。</p>
<p>为了对 AST 进行转换，我们需要能访问 AST 的每一个节点，这样才有机会对特定节点进行修改、替换、删除等操作。由于 AST 是树型数据结构，所以我们需要编写一个深度优先的遍历算法，从而实现对 AST 中节点的访问。</p>
<p>我们先完成一个工具函数<code>dump</code>用于打印节点信息：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dump</span>(<span class="hljs-params">node, indent = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = node.<span class="hljs-property">type</span><br><br>  <span class="hljs-keyword">const</span> desc = <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Root&#x27;</span><br>  ? <span class="hljs-string">&#x27;&#x27;</span><br>  : <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;Element&#x27;</span><br>    ? node.<span class="hljs-property">tag</span><br>    : node.<span class="hljs-property">content</span><br><br>  <span class="hljs-comment">// 打印节点信息</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-string">&#x27;-&#x27;</span>.repeat(indent)&#125;</span><span class="hljs-subst">$&#123;<span class="hljs-keyword">type</span>&#125;</span>: <span class="hljs-subst">$&#123;desc&#125;</span>`</span>)<br><br>  <span class="hljs-comment">// 递归打印</span><br>  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span>) &#123;<br>    node.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">AstNode</span></span>) =&gt;</span> &#123;<span class="hljs-title function_">dump</span>(child, indent + <span class="hljs-number">2</span>)&#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来，我们将着手实现对 AST 中节点的访问，从 AST 根节点开始，进行深度优先遍历，我们可以在遍历时对AST进行转换操作：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseNode</span>(<span class="hljs-params">ast</span>) &#123;<br>  <span class="hljs-comment">// 转换操作，任意</span><br>  <span class="hljs-keyword">if</span> (ast.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;Element&#x27;</span> &amp;&amp; ast.<span class="hljs-property">tag</span> = <span class="hljs-string">&#x27;p&#x27;</span>) ast.<span class="hljs-property">tag</span> = <span class="hljs-string">&#x27;h1&#x27;</span><br>  <span class="hljs-comment">// 有子节点则递归调用</span><br>  <span class="hljs-keyword">const</span> children = ast.<span class="hljs-property">children</span><br>  <span class="hljs-keyword">if</span> (children) &#123;<br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">AstNode</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">traverseNode</span>(child)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>随着功能的不断增加，<code>traverseNode</code>函数将会变得越来越“臃肿””，我们可以使用回调函数的机制来实现解<br>耦，为<code>traverseNode</code>函数添加一个上下文。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseNode</span>(<span class="hljs-params">ast, ctx</span>) &#123;<br><br>  <span class="hljs-comment">// 有子节点则递归调用</span><br>  <span class="hljs-keyword">const</span> children = ast.<span class="hljs-property">children</span><br>  <span class="hljs-comment">// 获取转换函数</span><br>  <span class="hljs-keyword">const</span> transforms = ctx.<span class="hljs-property">nodeTransforms</span><br><br>  transforms.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">transform</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">transform</span>(ast, ctx)<br>  &#125;)<br><br>  <span class="hljs-keyword">if</span> (children) &#123;<br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">AstNode</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">traverseNode</span>(child, ctx)<br>    &#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">ast</span>) &#123;<br>  <span class="hljs-keyword">const</span> ctx = &#123;<br>    <span class="hljs-attr">nodeTransforms</span>: [<br>      transformElement,<br>      transformText<br>    ]<br>  &#125;<br><br>  <span class="hljs-title function_">traverseNode</span>(ast, ctx)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformElement</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformText</span>(<span class="hljs-params"></span>) &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们继续丰富上下文信息的构造：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> transformCtx &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 转换函数组</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">nodeTransforms</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Function</span>&gt;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 当前转换节点</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">currentNode</span>: <span class="hljs-title class_">AstNode</span> | <span class="hljs-literal">null</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 当前节点在父节点的 children 中的位置索引。</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">childIndex</span>: <span class="hljs-built_in">number</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 当前节点父节点</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">parent</span>: <span class="hljs-title class_">AstNode</span> | <span class="hljs-literal">null</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 节点替换函数</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">replaceNode</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">AstNode</span></span>) =&gt;</span> <span class="hljs-built_in">void</span><br>    <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 节点移除函数</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">removeNode</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>修改<code>transform</code>和<code>traverseNode</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">transform</span>(<span class="hljs-params">ast</span>) &#123;<br>  <span class="hljs-keyword">const</span> ctx = &#123;<br>    <span class="hljs-attr">nodeTransforms</span>: [<br>      transformElement,<br>      transformText<br>    ],<br><br>    <span class="hljs-attr">currentNode</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">childIndex</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,<br><br>    <span class="hljs-title function_">replaceNode</span>(<span class="hljs-params">node</span>) &#123;<br>      <span class="hljs-comment">// 找到当前节点在父节点的 children 中的位置 context.childIndex 并替换即可</span><br>      <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">parent</span> &amp;&amp; ctx.<span class="hljs-property">parent</span>.<span class="hljs-property">children</span>) &#123;<br>        ctx.<span class="hljs-property">parent</span>.<span class="hljs-property">children</span>[ctx.<span class="hljs-property">childIndex</span>] = node<br>        <span class="hljs-comment">// 更新 currentNode</span><br>        ctx.<span class="hljs-property">currentNode</span> = node<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;children do not exist.&quot;</span>)<br>      &#125;<br>    &#125;,<br>      <br>    <span class="hljs-title function_">removeNode</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">parent</span> &amp;&amp; ctx.<span class="hljs-property">parent</span>.<span class="hljs-property">children</span>) &#123;<br>        <span class="hljs-comment">// 根据当前节点的索引删除当前节点</span><br>        ctx.<span class="hljs-property">parent</span>.<span class="hljs-property">children</span>.<span class="hljs-title function_">splice</span>(ctx.<span class="hljs-property">childIndex</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 置空 currentNode</span><br>        ctx.<span class="hljs-property">currentNode</span> = <span class="hljs-literal">null</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;children do not exist.&quot;</span>)<br>      &#125;<br>    &#125;<br>      <br>  &#125;<br><br>  <span class="hljs-title function_">traverseNode</span>(ast, ctx)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseNode</span>(<span class="hljs-params">ast, ctx</span>) &#123;<br>  ctx.<span class="hljs-property">currentNode</span> = ast<br><br>  ...<br>  <br>  transforms.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">transform</span> =&gt;</span> &#123;<br>    <span class="hljs-title function_">transform</span>(ast, ctx)<br>    <span class="hljs-comment">// 节点被删除则返回</span><br>    <span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">currentNode</span>) &#123; <span class="hljs-keyword">return</span> &#125;<br>  &#125;)<br><br>  <span class="hljs-keyword">if</span> (children) &#123;<br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-title class_">AstNode</span></span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 设置父节点</span><br>      ctx.<span class="hljs-property">parent</span> = ast<br>      <span class="hljs-comment">// 设置索引</span><br>      ctx.<span class="hljs-property">childIndex</span> = children.<span class="hljs-title function_">indexOf</span>(child)<br>      <span class="hljs-title function_">traverseNode</span>(child, ctx)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>目前的顺序处理的工作流存在的问题是，当一个节点被处理时，意味着它的父节点已经被处理完毕了，并且我们无法再回过头重新处理父节点。父节点的转换操作必须等待其所有子节点全部转换完毕后再执行，我们目前设计的转换工作流并不支持这一能力。</p>
<p><img src="https://pic.imgdb.cn/item/66d52887d9c307b7e9750555.png"></p>
<p>对节点的访问分为两个阶段，即进入阶段和退出阶段。当转换函数处于进入阶段时，它会先进入父节点，再进入子节点。而当转换函数处于退出阶段时，则会先退出子节点，再退出父节点。我们重新修改<code>traverseNode</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">traverseNode</span>(<span class="hljs-params"><span class="hljs-attr">ast</span>: <span class="hljs-title class_">AstNode</span>, <span class="hljs-attr">ctx</span>: transformCtx</span>) &#123;<br>  ctx.<span class="hljs-property">currentNode</span> = ast<br>  <span class="hljs-comment">// 退出阶段的回调函数数组</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">exitFns</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Function</span>&gt; = []<br>  ...<br><br>  transforms.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">transform</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 存储退出阶段的回调函数</span><br>    <span class="hljs-keyword">const</span> onExit = <span class="hljs-title function_">transform</span>(ctx.<span class="hljs-property">currentNode</span>, ctx)<br>    <span class="hljs-keyword">if</span> (onExit) &#123;<br>      exitFns.<span class="hljs-title function_">push</span>(onExit)<br>    &#125;<br>    ...<br>  &#125;)<br>	...<br>  <br>  <span class="hljs-comment">// 处理退出阶段回调函数，反序执行</span><br>  <span class="hljs-keyword">let</span> i = exitFns.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    exitFns[i]()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>traverseNode</code>函数的最后，执行这些缓存在<code>exitFns</code>数组中的回调函数保证当退出阶段的回调函数执行时，当前访问的节点的子节点已经全部处理过了。我们在编写转换函数时，可以将转换逻辑编写在退出阶段的回调函数中，从而保证在对当前访问的节点进行转换之前，其子节点一定全部处理完毕。</p>
<p>需要注意的是，退出阶段的回调函数是反序执行的。这意味着，如果注册了多个转换函数，则它们的注册顺序将决定代码的执行结果。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-attr">nodeTransForm</span>: [<br>	transformA,<br>    transformB<br>]<br><br><span class="hljs-comment">// 执行结果</span><br>transformA<br>transformB<br>transformB<br>transformA<br></code></pre></td></tr></table></figure>

<h2><span id="将模板-ast-转为-javascript-ast">将模板 AST 转为 JavaScript AST</span></h2><p>我们需要将模板 AST 转换为用于描述渲染函数的 JavaScript AST。下面时函数声明语句的组成：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">JavaScriptAstNode</span> &#123;<br>  <span class="hljs-attr">type</span>: <span class="hljs-built_in">string</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 标识符</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">id</span>: <span class="hljs-title class_">JavaScriptAstIdentifier</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 函数参数</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">params</span>: []<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 函数体</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JavaScriptAstState</span>[]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了简化问题，这里我们不考虑箭头函数、生成器函数、<code>async</code>函数等情况。</p>
<ul>
<li><code>id</code>：函数名称，它是一个标识符<code> Identifier</code>。</li>
<li><code>params</code>：函数的参数，它是一个数组。</li>
<li><code>body</code>：函数体，由于函数体可以包含多个语句，因此它也是一个数组。</li>
</ul>
<p>我们分别用<code>CallExpression, StringLiteral, ArrayExpression</code>分别描述函数调用、字符串字面量和数组：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 函数调用结构</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CallExp</span> &#123;<br><br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;CallExpression&quot;</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 用来描述被调用函数的名字称，它本身是一个标识符节点</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">callee</span>: <span class="hljs-title class_">Identifier</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 被调用函数的形式参数</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">arguments</span>: <span class="hljs-title class_">AstState</span>[]<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 字符串字面量</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StringLiteral</span> &#123;<br>  <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;StringLiteral&quot;</span><br>  <br>  <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span><br>  <br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数组</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ArrayExp</span> &#123;<br>  <br>  <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;ArrayExpression&quot;</span><br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 数组元素</span><br><span class="hljs-comment">   * */</span><br>  <span class="hljs-attr">elements</span>: []<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面是一个例子，使用之前的模板：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// &lt;div&gt;&lt;p&gt;MVVM&lt;/p&gt;&lt;p&gt;Template&lt;/p&gt;&lt;/div&gt;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">	function render() &#123;</span><br><span class="hljs-comment">		return h(&#x27;div&#x27;, [/* ... */</span>])<br>	&#125;<br>*/<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FunctionDeclNode</span> = &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;FunctionDecl&#x27;</span>	<span class="hljs-comment">// 表示函数声明</span><br>    <span class="hljs-attr">id</span>: &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>,<br>    	<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;render&#x27;</span> 		<span class="hljs-comment">// 存储标识符的名称</span><br>    &#125;,<br>	<span class="hljs-attr">params</span>: [],<br>    <span class="hljs-attr">body</span>: [<br>        &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ReturnStatement&#x27;</span>,<br>            <span class="hljs-comment">// 最外层 h 函数调用</span><br>            <span class="hljs-attr">return</span>: &#123;<br>                <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CallExpression&#x27;</span>,<br>                <span class="hljs-attr">callee</span>: &#123;<br>                    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;h&#x27;</span>,<br>                    <span class="hljs-attr">arguments</span>: [<br>                        <span class="hljs-comment">// 字符串字面量`div`</span><br>                        &#123;<br>                            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;StringLiteral&#x27;</span>,<br>                            <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;div&#x27;</span><br>                        &#125;,<br>                        <span class="hljs-comment">// 数组</span><br>                        &#123;<br>                            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ArrayExpression&#x27;</span>,<br>                            <span class="hljs-attr">elements</span>: [<br>                                <span class="hljs-comment">// h 函数调用</span><br>                                &#123;<br>                                    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CallExpression&#x27;</span>,<br>                                    <span class="hljs-attr">callee</span>: &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;h&#x27;</span>&#125;,<br>                                    <span class="hljs-attr">arguments</span>: &#123;<br>                                        &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;StringLiteral&quot;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;p&#x27;</span>&#125;,<br>                                    	&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&quot;StringLiteral&quot;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Vue&#x27;</span>&#125;,<br>                                    &#125;<br>                                &#125;,<br>                        		<span class="hljs-comment">// 另一节点类似，省略</span><br>                            ]<br>                        &#125;<br>                    ]<br>                &#125;<br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们开始编写转换函数，将模板 AST 转换为上述 JavaScript AST。不过在开始之前，我们需要编写一些用来创建 JavaScript AST 节点的辅助函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建 StringLiteral 节点</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-title function_">createStringLiteral</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;StringLiteral&#x27;</span>,<br>    <span class="hljs-attr">value</span>: value<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建 Identifier 节点</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createIdentifier</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>,<br>    <span class="hljs-attr">name</span>: name<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建 ArrayExpression 节点</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ArrayExpression</span>(<span class="hljs-params">elements</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;ArrayExpression&#x27;</span>,<br>    <span class="hljs-attr">elements</span>: elements<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建 CallExpression 节点</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">CallExpression</span>(<span class="hljs-params">callee, args</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;CallExpression&#x27;</span>,<br>    <span class="hljs-attr">callee</span>: <span class="hljs-title function_">createIdentifier</span>(callee),<br>    <span class="hljs-attr">arguments</span>: args<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了把模板 AST 转换为 JavaScript AST，我们同样需要两个转换函数<code>transformElement</code>和<code> transformText</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转换标签节点</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformElement</span>(<span class="hljs-params">node</span>) &#123;<br>  <span class="hljs-comment">// 将转换代码编写在退出阶段的回调函数中，保证该标签节点的子节点全部被处理完毕</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 不是元素节点则返回</span><br>    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">type</span> !== <span class="hljs-string">&quot;Element&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 创建 h 函数调用语句</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">callExp</span>: <span class="hljs-title class_">CallExp</span> = <span class="hljs-title function_">createCallExpression</span>(<span class="hljs-string">&#x27;h&#x27;</span>, [<br>      <span class="hljs-title function_">createStringLiteral</span>(node.<span class="hljs-property">tag</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>)<br>    ])<br><br>    <span class="hljs-comment">// 处理 h 函数调用的参数</span><br>    <span class="hljs-keyword">if</span> (node.<span class="hljs-property">children</span> &amp;&amp; node.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">jsNode</span>) &#123;<br>      node.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> === <span class="hljs-number">1</span><br>      <span class="hljs-comment">// 只有一个子节点则使用 jsNode 作为参数</span><br>      ? callExp.<span class="hljs-property">arguments</span>.<span class="hljs-title function_">push</span>(node.<span class="hljs-property">children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">jsNode</span>)<br>      <span class="hljs-comment">// 有多个子节点则创建 ArrayExpression 作为参数</span><br>      : callExp.<span class="hljs-property">arguments</span>.<span class="hljs-title function_">push</span>(<br>          <span class="hljs-title function_">createArrayExpression</span>(node.<span class="hljs-property">children</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.<span class="hljs-property">jsNode</span>))<br>        )<br>    &#125;<br><br>    <span class="hljs-comment">// 添加到 jsNode</span><br>    node.<span class="hljs-property">jsNode</span> = callExp<br><br>  &#125;<br><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">transformText</span>(<span class="hljs-params">node</span>) &#123;<br>  <span class="hljs-comment">// 不是文本节点则不处理</span><br>  <span class="hljs-keyword">if</span> (node.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;Text&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br><br>  <span class="hljs-comment">// 使用 node.content 创建一个 StringLiteral 类型的节点，添加到 node.jsNode 属性下</span><br>  node.<span class="hljs-property">jsNode</span> = <span class="hljs-title function_">createStringLiteral</span>(node.<span class="hljs-property">content</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>转换后得到的 AST 只是用来描述渲染函数<code>render</code>的返回值的，所以我们最后一步要做的就是，补全 JavaScript AST，即把用来描述 render 函数本身的函数声明语句节点附加到 JavaScript AST 中。这需要我们编写<code>transformRoot</code>函数来实现对 Root 根节点的转换：</p>
<h2><span id="代码生成">代码生成</span></h2><p>我们将实现 generate 函数来完成代码生成的任务，代码生成也是编译器的最后一步。与 AST 转换一样，代码生成也需要上下文对象。该上下文对象用来维护代码生成过程中程序的运行状态：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params">node</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">ctx</span>: generateCtx = &#123;<br>    <span class="hljs-comment">// 存储最终生成的渲染代码</span><br>    <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-title function_">push</span>(<span class="hljs-params"><span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>      ctx.<span class="hljs-property">code</span> += code<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 代码生成</span><br>  <span class="hljs-title function_">genNode</span>(node, ctx)<br>  <br>  <span class="hljs-comment">// 返回渲染函数代码</span><br>  <span class="hljs-keyword">return</span> ctx.<span class="hljs-property">code</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们希望最终生成的代码具有较强的可读性，因此我们应该考虑生成代码的格式，例如缩进和换行等。这就需要我们扩展<code>context</code>对象，为其增加用来完成换行和缩进的工具函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">generate</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">JsAstNode</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">ctx</span>: generateCtx = &#123;<br>    <span class="hljs-comment">// 存储最终生成的渲染代码</span><br>    <span class="hljs-attr">code</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-title function_">push</span>(<span class="hljs-params"><span class="hljs-attr">code</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>      ctx.<span class="hljs-property">code</span> += code<br>    &#125;,<br><br>    <span class="hljs-attr">currentIndent</span>: <span class="hljs-number">0</span>,<br><br>    <span class="hljs-title function_">newline</span>(<span class="hljs-params"></span>) &#123;<br>      ctx.<span class="hljs-property">code</span> += <span class="hljs-string">&#x27;\n&#x27;</span> + <span class="hljs-string">`  `</span>.<span class="hljs-title function_">repeat</span>(ctx.<span class="hljs-property">currentIndent</span>)<br>    &#125;,<br>    <br>    <span class="hljs-title function_">indent</span>(<span class="hljs-params"></span>) &#123;<br>      ctx.<span class="hljs-property">currentIndent</span>++<br>      ctx.<span class="hljs-title function_">newline</span>()<br>    &#125;,<br><br>    <span class="hljs-title function_">deIndent</span>(<span class="hljs-params"></span>) &#123;<br>      ctx.<span class="hljs-property">currentIndent</span>--<br>      ctx.<span class="hljs-property">newline</span><br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-comment">// 代码生成</span><br>  <span class="hljs-title function_">genNode</span>(node, ctx)<br><br>  <span class="hljs-comment">// 返回渲染函数代码</span><br>  <span class="hljs-keyword">return</span> ctx.<span class="hljs-property">code</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>有了这些基础能力之后，我们就可以开始编写<code>genNode</code>函数来完成代码生成的工作了。代码生成的原理其实很简单，只需要匹配各种类型的 JavaScript AST 节点，并调用对应的生成函数即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">genNode</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">JsAstNode</span>, <span class="hljs-attr">context</span>: generateCtx</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (node.<span class="hljs-property">type</span>) &#123;<br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;FunctionDecl&#x27;</span>:<br>      <span class="hljs-title function_">genFunctionDecl</span>(node, context)<br>      <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ReturnStatement&#x27;</span>:<br>      <span class="hljs-title function_">genReturnStatement</span>(node, context)<br>      <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;CallExpression&#x27;</span>:<br>      <span class="hljs-title function_">genCallExpression</span>(node, context)<br>      <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;StringLiteral&#x27;</span>:<br>      <span class="hljs-title function_">genStringLiteral</span>(node, context)<br>      <span class="hljs-keyword">break</span><br><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;ArrayExpression&#x27;</span>:<br>      <span class="hljs-title function_">genArrayExpression</span>(node, context)<br>      <span class="hljs-keyword">break</span><br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来我们分别实现每一种情况对应的生成函数。首先来看<code>genFunctionDecl</code>，用来为函数声明类型的节点生成对应的 JavaScript 代码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">genFunctionDecl</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">JsAstNode</span>, <span class="hljs-attr">context</span>: generateCtx</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; push, indent, deIndent&#125; = context<br><br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">`function <span class="hljs-subst">$&#123;(node.id <span class="hljs-keyword">as</span> Identifier).name&#125;</span>`</span>)<br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">`(`</span>)<br>  <span class="hljs-comment">// 调用 genNodeList</span><br>  <span class="hljs-title function_">genNodeList</span>(node.<span class="hljs-property">params</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>[], context)<br>  <span class="hljs-title function_">push</span>(<span class="hljs-params"><span class="hljs-string">`) &#123;`</span></span>)<br>  <span class="hljs-comment">// 缩进</span><br>  <span class="hljs-title function_">indent</span>()<br>  <span class="hljs-comment">// 递归为函数体生成代码</span><br>  (node.<span class="hljs-property">body</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">JsAstNode</span>[]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-title class_">JsAstNode</span></span>) =&gt;</span> <span class="hljs-title function_">genNode</span>(n, context))<br>  <span class="hljs-comment">// 取消缩进</span><br>  <span class="hljs-title function_">deIndent</span>()<br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">genNodeList</span>(<span class="hljs-params"><span class="hljs-attr">params</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">JsAstNode</span>&gt;, <span class="hljs-attr">context</span>: generateCtx</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; push &#125; = context<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; params.<span class="hljs-property">length</span> ; i++) &#123;<br>    <span class="hljs-keyword">const</span> param = params[i]<br>    <span class="hljs-title function_">genNode</span>(param, context)<br><br>    <span class="hljs-keyword">if</span> (i &lt; params.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;, &#x27;</span>)<br>    &#125;<br>      <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里有一个需要注意的点：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">indent</span>()<br><span class="hljs-comment">// 递归为函数体生成代码</span><br>(node.<span class="hljs-property">body</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">JsAstNode</span>[]).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">n</span>: <span class="hljs-title class_">JsAstNode</span></span>) =&gt;</span> <span class="hljs-title function_">genNode</span>(n, context))<br></code></pre></td></tr></table></figure>

<p>这段代码经过Webpack打包后的代码为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 缩进</span><br><span class="hljs-title function_">indent</span>()(node.<span class="hljs-property">body</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> <span class="hljs-title function_">genNode</span>(n, context));<br></code></pre></td></tr></table></figure>

<p>会引发<code>indent() is not a function</code>错误。为了避免这个问题，最好在<code>indent()</code>后面加上<code>;</code>。</p>
</blockquote>
<p><code>genArrayExpression</code>函数的实现与<code>genNodelist</code>相似，只需要包裹<code>[]</code>即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">genArrayExpression</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">ArrayExp</span>, <span class="hljs-attr">context</span>: generateCtx</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; push &#125; = context<br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;[&#x27;</span>)<br>  <span class="hljs-title function_">genNodeList</span>(node.<span class="hljs-property">elements</span>, context)<br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;]&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>genCallExpression</code>也用到了<code>genNodeList</code>用于处理参数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">genCallExpression</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">CallExp</span>, <span class="hljs-attr">context</span>: generateCtx</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; push &#125; = context<br>  <span class="hljs-comment">// 获取被调用函数名称和参数</span><br>  <span class="hljs-keyword">const</span> &#123; callee, <span class="hljs-attr">arguments</span>: args &#125; = node<br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;callee.name&#125;</span>(`</span>)<br>  <span class="hljs-title function_">genNodeList</span>(args, context)<br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于<code>ReturnStatement</code>和<code>StringLiteral</code>类型的节点来说，为它们生成代码很简单：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">genReturnStatement</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">JsAstNode</span>, <span class="hljs-attr">context</span>: generateCtx</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; push &#125; = context<br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;return &#x27;</span>)<br>  <span class="hljs-title function_">genNode</span>(node.<span class="hljs-property">return</span>, context)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">genStringLiteral</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">StringLiteral</span>, <span class="hljs-attr">context</span>: generateCtx</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; push &#125; = context<br>  <span class="hljs-title function_">push</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;node.value&#125;</span>`</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h1><span id="解析器">解析器</span></h1><p>我们将更多地利用正则表达式来实现 HTML 解析器。WHATWG 关于 HTML 的解析规范，其中定义了完整的错误处理和状态机的状态迁移流程，还提及了一些特殊的状态，例如 DATA、CDATA、RCDATA、RAWTEXT 等。</p>
<h2><span id="文本模式">文本模式</span></h2><p>文本模式指的是解析器在工作时所进入的一些特殊状态，在不同的特殊状态下，解析器对文本的解析行为会有所不同。具体来说，当解析器遇到一些特殊标签时，会切换模式，从而影响其对文本的解析行为。这些特殊标签是：</p>
<ul>
<li><code>&lt;title&gt;, &lt;textarea&gt;</code>标签会切换到<code>RCDATA</code>模式</li>
<li><code>&lt;style&gt;, &lt;xmp&gt;, &lt;iframe&gt;, &lt;noembed&gt;, &lt;noframes&gt;, &lt;noscript&gt;</code>等标签会切换到<code>RAWTEXT</code> 模式</li>
<li>当解析器遇到<code>&lt;![CDATA[</code>字符串进入<code>CDATA</code>模式</li>
</ul>
<p>解析器的初始模式则是 DATA 模式。对于 Vue 的模板 DSL 来说，模板中不允许出现<code>&lt;script&gt;</code>标签，因此 Vue 模板解析器在遇到<code>&lt;script&gt;</code>标签时也会切换到 RAWTEXT 模式。</p>
<p>在默认的 DATA 模式下：</p>
<ul>
<li>解析器在遇到字符<code>&lt;</code>时，会切换到标签开始状态（tag open state）。换句话说，在该模式下，解析器能够解析标签元素。</li>
<li>当解析器遇到字符<code>&amp;</code>时，会切换到字符引用状态（character reference state），也称 HTML字符实体状态。也就是说，在 DATA 模式下，解析器能够处理 HTML字符实体。</li>
</ul>
<p>在 RCDATA 状态下：</p>
<ul>
<li>当解析器遇到字符<code>&lt;</code>时，不会再切换到标签开始状态，而会切换到<code>RCDATA less-than sign state</code>状态。<ul>
<li>如果解析器遇到字符<code> /</code>，则直接切换到 RCDATA 的结束标签状态，即<code> RCDATA end tag open state</code></li>
<li>否则会将当前字符<code>&lt;</code>作为普通字符处理，然后继续处理后面的字符，间接说明了在<code> &lt;textarea&gt;</code>内可以将字符 &lt; 作为普通文本，解析器并不会认为字符<code>&lt;</code>是标签开始的标志</li>
<li>解析器仍然支持 HTML 实体。因为当解析器遇到字符<code>&amp;</code>时，会切换到字符引用状态</li>
</ul>
</li>
</ul>
<p>在 RAWTEXT 模式下的工作方式与在 RCDATA 模式下类似：</p>
<ul>
<li>解析器会将 HTML 实体字符作为普通字符处理。</li>
</ul>
<p>CDATA 模式在 RAWTEXT 模式的基础上更进一步：</p>
<ul>
<li>解析器将把任何字符都作为普通字符处理，直到遇到 CDATA 的结束标志为止。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">能否解析标签</th>
<th align="center">能否支持HTML实体</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DATA</td>
<td align="center">能</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">RCDATA</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">RAWTEXT</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center">CDATA</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p>后续编写解析器代码时，我们会将上述模式定义为状态表：</p>
<h2><span id="递归下降算法构造模板-ast">递归下降算法构造模板 AST</span></h2><p>解析器的基本架构模型如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params"><span class="hljs-attr">templateStr</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-title class_">AstNode</span> &#123;<br>  <span class="hljs-comment">// 解析器上下文</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">context</span>: parseCtx = &#123;<br>    <span class="hljs-comment">// 模板内容</span><br>    <span class="hljs-attr">source</span>: templateStr,<br>    <span class="hljs-comment">// 解析器模式</span><br>    <span class="hljs-attr">mode</span>: <span class="hljs-title class_">TextModes</span>.<span class="hljs-property">DATA</span><br>  &#125;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">nodes</span>: <span class="hljs-title class_">AstNode</span>[] = <span class="hljs-title function_">parseChildren</span>(context, [])<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Root&#x27;</span>,<br>    <span class="hljs-attr">children</span>: nodes<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>与之前的实现不同，创建 Token 与构造模板 AST 的过程可以同时进行，因为模板和模板 AST 具有同构的特性。<code>parseChildren</code>函数是整个解析器的核心。后续我们会递归地调用它来不断地消费模板内容。<code>parseChildren</code>函数会返回解析后得到的子节点。</p>
<p><code>parseChildren</code>函数本质上也是一个状态机，该状态机有多少种状态取决于子节点的类型数量：</p>
<ul>
<li>标签节点，例如<code> &lt;div&gt;</code>。</li>
<li>文本插值节点，例如<code> &#123;&#123; val &#125;&#125;</code>。</li>
<li>普通文本节点，例如：<code>text</code>。</li>
<li>注释节点，例如<code> &lt;!----&gt;</code>。</li>
<li><code>CDATA</code>节点，例如<code> &lt;![CDATA[ xxx ]]&gt;</code></li>
</ul>
<p><img src="https://pic.imgdb.cn/item/66d66559d9c307b7e9e78b48.png"></p>
<blockquote>
<p>注意正则表达式<code>/a-z/i</code>中的<code> i</code>，意思是忽略大小写（case insensitive）。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseChildren</span>(<span class="hljs-params"><span class="hljs-attr">ctx</span>: parseCtx, <span class="hljs-attr">ancestors</span>: <span class="hljs-title class_">AstNode</span>[]</span>) &#123;<br>  <span class="hljs-comment">// 定义数组存储子节点</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">nodes</span>: <span class="hljs-title class_">AstNode</span>[] = []<br>  <span class="hljs-keyword">const</span> &#123; mode, source &#125; = ctx<br><br>  <span class="hljs-keyword">while</span>(!<span class="hljs-title function_">isEnd</span>(ctx, ancestors)) &#123;<br>    <span class="hljs-keyword">let</span> node<br>    <span class="hljs-comment">// DATA RCDATA 模式才支持插值节点的解析</span><br>    <span class="hljs-keyword">if</span> (mode === <span class="hljs-title class_">TextModes</span>.<span class="hljs-property">DATA</span> || mode === <span class="hljs-title class_">TextModes</span>.<span class="hljs-property">RCDATA</span>) &#123;<br>      <span class="hljs-comment">// 只有 DATA 模式才支持标签节点解析</span><br>      <span class="hljs-keyword">if</span> (mode === <span class="hljs-title class_">TextModes</span>.<span class="hljs-property">DATA</span> &amp;&amp; source[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;&lt;&#x27;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (source[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>          <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;&lt;!--&#x27;</span>)) &#123;<br>            <span class="hljs-comment">// 注释</span><br>            node = <span class="hljs-title function_">parseComment</span>(ctx)<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;&lt;![CDATA[&#x27;</span>)) &#123;<br>            <span class="hljs-comment">// CDATA</span><br>            node = <span class="hljs-title function_">parseCDATA</span>(ctx, ancestors)<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (source[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 结束标签，报错</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/a-z/i</span>.<span class="hljs-title function_">test</span>(source[<span class="hljs-number">1</span>])) &#123;<br>        <span class="hljs-comment">// 标签元素</span><br>        node = <span class="hljs-title function_">parseElement</span>(ctx, ancestors)<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (source.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;&#123;&#123;&#x27;</span>)) &#123;<br>        <span class="hljs-comment">// 解析插值</span><br>        node = <span class="hljs-title function_">parseInterpolation</span>(ctx)<br>      &#125;<br>    &#125; <br>    <br>    <span class="hljs-comment">// node 不存在，作为文本处理</span><br>    <span class="hljs-keyword">if</span> (!node) &#123;<br>      <span class="hljs-comment">// 解析文本节点</span><br>      node = <span class="hljs-title function_">parseText</span>(ctx)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 将节点添加到 nodes</span><br>    nodes.<span class="hljs-title function_">push</span>(node)<br>    <br>  &#125;<br><br>  <span class="hljs-keyword">return</span> nodes<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在解析模板时，我们不能忽略空白字符。这些空白字符包括：换行符（\n）、回车符（\r）、空格（’ ‘）、制表符（\t）以及换页符（\f）。我们用加号（+）代表换行符，用减号（-）代表空格字符</p>
<p>接下来我们先实现元素标签解析<code>parseElement</code>。如果一个标签不是自闭合标签，则可以认为，一个完整的标签元素是由开始标签、子节点和结束标签这三部分构成的。为了解析标签的子节点，我们递归地调用了<code>parseChildren</code>函数。这意味着，一个新的状态机开始运行了。随着标签嵌套层次的增加，新的状态机会随着<code>parseChildren</code>函数被递归地调用而不断创建，这就是“递归下降”中“递归”二字的含义。而上级<code>parseChildren</code>函数的调用用于构造上级模板 AST 节点，被递归调用的下级<code>parseChildren</code>函数则用于构造下级模板 AST 节点。最终，会构造出一棵树型结构的模板 AST，这就是“递归下降”中“下降”二字的含义。</p>
<h2><span id="状态机的开启与停止">状态机的开启与停止</span></h2><p>我们在上一节中有一个没有实现的函数<code>isEnd</code>，这个函数用于判断状态机何时停止。</p>
<p><img src="https://pic.imgdb.cn/item/66d670c4d9c307b7e9f634d3.png"></p>
<p>此时“状态机 2”拥有程序的执行权，它持续解析模板直到遇到结束标签<code> &lt;/p&gt;</code>。因为这是一个结束标签，并且在父级节点栈中存在与该结束标签同名的标签节点，所以“状态机 2”会停止运行，并弹出父级节点栈中处于栈顶的节点。此时“状态机 2”已经停止运行了，但“状态机 1”仍在运行中，于是会继续解析模板，直到遇到下一个<code>&lt;p&gt;</code>标签。这时“状态机 1”会再次调用<code>parseElement</code>函数解析标签节点，因此又会执行压栈并开启新的“状态机 3”。</p>
<p>“状态机 3 ”会继续解析模板，直到遇到结束标签<code> &lt;/p&gt;</code>。因为这是一个结束标签，并且在父级节点栈中存在与该结束标签同名的标签节点，所以“状态机 3”会停止运行，并弹出父级节点栈中处于栈顶的节点。当“状态机 3”停止运行后，程序的执行权交还给“状态机 1”。“状态机 1”会继续解析模板，直到遇到最后的<code>&lt;/div&gt;</code>结束标签。这时“状态机 1”发现父级节点栈中存在与结束标签同名的标签节点，于是将该节点弹出父级节点栈：<br><img src="https://pic.imgdb.cn/item/66d6730fd9c307b7e9f7cef8.png"></p>
<p>这时父级节点栈为空，状态机全部停止运行，模板解析完毕。当解析器遇到开始标签时，会将该标签压入父级节点栈，同时开启新的状态机。当解析器遇到结束标签，并且父级节点栈中存在与该标签同名的开始标签节点时，会停止当前正在运行的状态机。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isEnd</span>(<span class="hljs-params"><span class="hljs-attr">ctx</span>: parseCtx, <span class="hljs-attr">ancestors</span>: <span class="hljs-title class_">AstNode</span>[]</span>) &#123;<br>  <span class="hljs-comment">// 模板内容解析完毕后停止</span><br>  <span class="hljs-keyword">if</span> (!ctx.<span class="hljs-property">source</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment">// 获取父级标签节点</span><br>  <span class="hljs-keyword">const</span> parent = ancestors[ancestors.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]<br>  <span class="hljs-comment">// 如果遇到结束标签，并且该标签与父级标签节点同名，则停止</span><br>  <span class="hljs-keyword">if</span> (parent &amp;&amp; ctx.<span class="hljs-property">source</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">`&lt;/<span class="hljs-subst">$&#123;parent.tag&#125;</span>`</span>)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>目前的实现有个问题：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>有两种解释方式：</p>
<ul>
<li><p>“状态机 3”遭遇了不符合预期的状态，因为结束标签<code> &lt;/div&gt;</code>缺少与之对应的开始标签，所以这时“状态机 3”会抛出错误：“无效的结束标签”。</p>
<p><img src="https://pic.imgdb.cn/item/66d6771dd9c307b7e9fa8970.png"></p>
<p>在<code>parseChildren</code>中体现为：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (source[<span class="hljs-number">1</span>] === <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 结束标签，报错</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`invalid tag <span class="hljs-subst">$&#123;ctx.source&#125;</span>`</span>)<br>    <span class="hljs-keyword">continue</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在这个过程中，“状态机 2”在调用<code>parseElement</code>解析函数时，<code>parseElement</code>函数能够发现<code>&lt;span&gt;</code>缺少闭合标签，于是会打印错误信息“<code>&lt;span&gt; </code>标签缺少闭合标签”</p>
<p><img src="https://pic.imgdb.cn/item/66d67953d9c307b7e9fbfbe2.png"></p>
<p>在<code>parseElement</code>中处理该错误。</p>
</li>
</ul>
<p>我们先来实现辅助函数<code>parseTag</code>和<code>parseEndTag</code>。我们为上下文对象增加了<code>advanceBy</code>函数和<code>advanceSpaces</code>函数。其中<code>advanceBy</code>函数用来消费指定数量的字符。<code>advanceSpaces</code>函数则用来消费无用的空白字符，因为标签中可能存在空白字符，例如在模板<code>&lt;div----&gt; </code>中减号（-）代表空白字符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 解析器上下文</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">context</span>: parseCtx = &#123;<br>    <span class="hljs-comment">// 模板内容</span><br>    <span class="hljs-attr">source</span>: templateStr,<br>    <span class="hljs-comment">// 解析器模式</span><br>    <span class="hljs-attr">mode</span>: <span class="hljs-title class_">TextModes</span>.<span class="hljs-property">DATA</span>,<br><br>    <span class="hljs-comment">// 消费指定数量的字符</span><br>    <span class="hljs-title function_">advanceBy</span>(<span class="hljs-params"><span class="hljs-attr">num</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>      <span class="hljs-comment">// 截取位置 num 后的模板内容，并替换当前模板内容</span><br>      context.<span class="hljs-property">source</span> = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">slice</span>(num)<br>    &#125;,<br><br>    <span class="hljs-comment">// 清除空白字符</span><br>    <span class="hljs-title function_">advanceSpaces</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> match = <span class="hljs-regexp">/^[\t\r\n\f ]+/</span>.<span class="hljs-title function_">exec</span>(context.<span class="hljs-property">source</span>)<br>      <span class="hljs-keyword">if</span> (match) &#123;<br>        <span class="hljs-comment">// 调用 advanceBy 清除</span><br>        context.<span class="hljs-title function_">advanceBy</span>(match[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>)<br>      &#125;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>有了<code>advanceBy</code>和 <code>advanceSpaces </code>函数后，我们就可以给出<code>parseTag</code>函数的实现了，如下面的代码所示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseTag</span>(<span class="hljs-params">context, <span class="hljs-keyword">type</span> = <span class="hljs-string">&#x27;start&#x27;</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; advanceBy, advanceSpaces &#125; = context<br><br>  <span class="hljs-comment">// 处理开始标签和结束标签</span><br>  <span class="hljs-keyword">const</span> match = <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;start&#x27;</span><br>    <span class="hljs-comment">// 开始标签</span><br>    ? <span class="hljs-regexp">/^&lt;([a-z][^\t\r\n\f /&gt;]*)/i</span>.<span class="hljs-title function_">exec</span>(context.<span class="hljs-property">source</span>)<br>    <span class="hljs-comment">// 结束标签</span><br>    : <span class="hljs-regexp">/^&lt;\/([a-z][^\t\r\n\f /&gt;]*)/i</span>.<span class="hljs-title function_">exec</span>(context.<span class="hljs-property">source</span>)<br><br>  <span class="hljs-comment">// 匹配成功正则表达式第一个捕获组的值就是标签名称</span><br>  <span class="hljs-keyword">if</span> (match) &#123;<br>    <span class="hljs-keyword">const</span> tag = match[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment">// 清除正则表达式匹配的全部内容</span><br>    <span class="hljs-title function_">advanceBy</span>(match[<span class="hljs-number">0</span>])<br>    <span class="hljs-title function_">advanceSpaces</span>()<br><br>    <span class="hljs-comment">// 如果消除后字符串以 /&gt; 开头则是自闭合标签</span><br>    <span class="hljs-keyword">const</span> isSelfClosing = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;/&gt;&quot;</span>)<br>    <span class="hljs-comment">// 如果是自闭合标签，则消费 &#x27;/&gt;&#x27;， 否则消费 &#x27;&gt;&#x27;</span><br>    <span class="hljs-title function_">advanceBy</span>(isSelfClosing ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// 返回标签节点</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Element&#x27;</span>,<br>      <span class="hljs-attr">tag</span>: tag,<br>      <span class="hljs-attr">props</span>: [],<br>      <span class="hljs-attr">children</span>: [],<br>      <span class="hljs-attr">isSelfClosing</span>: isSelfClosing<br>    &#125;<br>    <br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;tag does not match.&quot;</span>)<br>    <span class="hljs-keyword">return</span> <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现了<code>parseTag</code>，我们就可以开始实现<code>parseElement</code>了：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseElement</span>(<span class="hljs-params"><span class="hljs-attr">context</span>: parseCtx, <span class="hljs-attr">ancestors</span>: <span class="hljs-title class_">AstNode</span>[]</span>) &#123;<br>  <span class="hljs-keyword">const</span> element = <span class="hljs-title function_">parseTag</span>(context) <span class="hljs-keyword">as</span> <span class="hljs-title class_">AstNode</span><br>  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">isSelfClosing</span>) <span class="hljs-keyword">return</span> element<br><br>  <span class="hljs-comment">// 切换到正确的文本模式</span><br>  <span class="hljs-keyword">if</span> (element.<span class="hljs-property">tag</span> === <span class="hljs-string">&#x27;textarea&#x27;</span> || element.<span class="hljs-property">tag</span> ===<span class="hljs-string">&#x27;title&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 解析得到的标签是 &lt;textarea&gt; 或 &lt;title&gt; 切换RCDATA模式</span><br>    context.<span class="hljs-property">mode</span> = <span class="hljs-title class_">TextModes</span>.<span class="hljs-property">RCDATA</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/style | xmp | iframe | noembed | noframes | noscipt/</span>.<span class="hljs-title function_">test</span>(element.<span class="hljs-property">tag</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>)) &#123;<br>    <span class="hljs-comment">// 上述情况切换 RAWTEXT</span><br>    context.<span class="hljs-property">mode</span> = <span class="hljs-title class_">TextModes</span>.<span class="hljs-property">RAWTEXT</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 其他情况切换到 DATA 模式</span><br>    context.<span class="hljs-property">mode</span> = <span class="hljs-title class_">TextModes</span>.<span class="hljs-property">DATA</span><br>  &#125;<br><br>  ancestors.<span class="hljs-title function_">push</span>(element)<br>  <span class="hljs-comment">// 递归地调用 parseChildren 函数进行标签子节点的解析</span><br>  element.<span class="hljs-property">children</span> = <span class="hljs-title function_">parseChildren</span>(context, ancestors)<br>  ancestors.<span class="hljs-title function_">pop</span>()<br><br>  <span class="hljs-keyword">if</span> (context.<span class="hljs-property">source</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">`&lt;/<span class="hljs-subst">$&#123;element.tag&#125;</span>`</span>)) &#123;<br>    <span class="hljs-title function_">parseTag</span>(context, <span class="hljs-string">&#x27;end&#x27;</span>)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 缺少闭合标签</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;element.tag&#125;</span> is lack of end tag.`</span>)<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> element<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="解析属性">解析属性</span></h2><p><code>parseTag</code>解析函数会消费整个开始标签，这意味着该函数需要有能力处理开始标签中存在属性与指令。为了处理属性和指令，我们需要在<code>parseTag</code>函数中增加<code>parseAttributes </code>解析函数。我们先来看<code>parseAttributes</code>函数：</p>
<p><img src="https://pic.imgdb.cn/item/66d6afaed9c307b7e938d06b.png"></p>
<p><code>parseAttributes</code>函数消费模板内容的过程，就是不断地解析属性名称、等于号、属性值的过程。在属性名称解析完毕之后，模板剩余内容一定是以等于号开头的，即：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">= &#x27;foo&#x27; v-show=&#x27;display&#x27;&gt;<br></code></pre></td></tr></table></figure>

<p>我们需要消费等于号字符。由于等于号和属性值之间也可能存在空白字符，所以我们也需要消费对应的空白字符。接下来，到了处理属性值的环节。模板中的属性值存在三种情况：</p>
<ul>
<li>属性值被双引号包裹：<code>id=&quot;foo&quot;</code></li>
<li>属性值被单引号包裹：<code>id=&#39;foo&#39;</code></li>
<li>属性值没有引号包裹：<code>id=foo</code></li>
</ul>
<p>因此我们可以通过检查当前模板内容是否以引号开头来确定属性值是否被引用。既然属性值被引号引用了，就意味着在剩余模板内容中，下一个引号之前的内容都应该被解析为属性值。如果属性值没有被引号引用，那么在剩余模板内容中，下一个空白字符之前的所有字符都应该作为属性值。</p>
<p>当属性值和引号被消费之后，由于属性值与下一个属性名称之间可能存在空白字符，所以我们还要消费对应的空白字符。</p>
<p>接下来重新执行上述步骤直到遇到标签的“结束部分”，即字符<code>&gt;</code>，这时，<code>parseAttributes</code>函数中的 while 循环将会停止，完成属性和指令的解析。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseAttributes</span>(<span class="hljs-params"><span class="hljs-attr">context</span>: parseCtx</span>) &#123;<br>  <br>  <span class="hljs-keyword">const</span> &#123; advanceBy, advanceSpaces &#125; = context<br>  <span class="hljs-comment">// 存储属性和指令节点</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">props</span>: <span class="hljs-built_in">any</span>[] = []<br><br>  <span class="hljs-keyword">while</span> (!context.<span class="hljs-property">source</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;&gt;&#x27;</span>) &amp;&amp; <br>        !context.<span class="hljs-property">source</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/&gt;&#x27;</span>)) &#123;<br>    <span class="hljs-comment">// 正则匹配名称</span><br>    <span class="hljs-keyword">const</span> match = <span class="hljs-regexp">/^[\t\r\n\f /&gt;][^\t\r\n\f /&gt;=]*/</span>.<span class="hljs-title function_">exec</span>(context.<span class="hljs-property">source</span>)<br>    <br>    <span class="hljs-keyword">if</span> (match) &#123;<br>      <span class="hljs-comment">// 获取属性名称</span><br>      <span class="hljs-keyword">const</span> name = match[<span class="hljs-number">0</span>]<br>      <br>      <span class="hljs-comment">// 消费属性名</span><br>      <span class="hljs-title function_">advanceBy</span>(name.<span class="hljs-property">length</span>)<br>      <span class="hljs-comment">// 消除空白字符</span><br>      <span class="hljs-title function_">advanceSpaces</span>()<br>      <span class="hljs-comment">// 消费 =</span><br>      <span class="hljs-title function_">advanceBy</span>(<span class="hljs-number">1</span>)<br>      <span class="hljs-comment">// 消费空白字符</span><br>      <span class="hljs-title function_">advanceSpaces</span>()<br>      <br>      <span class="hljs-comment">// 属性值</span><br>      <span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;&#x27;</span><br>      <br>      <span class="hljs-comment">// 获取当前模板内容的第一个字符</span><br>      <span class="hljs-keyword">const</span> quote = context.<span class="hljs-property">source</span>[<span class="hljs-number">0</span>]<br>      <span class="hljs-comment">// 判断属性值是否被引号引用</span><br>      <span class="hljs-keyword">const</span> isQuoted = quote === <span class="hljs-string">&#x27;&quot;&#x27;</span> || quote === <span class="hljs-string">&quot;&#x27;&quot;</span><br>      <br>      <span class="hljs-keyword">if</span> (isQuoted) &#123;<br>        <span class="hljs-comment">// 属性值被引号引用，消费引号</span><br>        <span class="hljs-title function_">advanceBy</span>(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment">// 获取下一个引号索引</span><br>        <span class="hljs-keyword">const</span> endQuoteIndex = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">indexOf</span>(quote)<br>        <span class="hljs-keyword">if</span> (endQuoteIndex &gt; -<span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">// 获取属性值</span><br>          value = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, endQuoteIndex)<br>          <span class="hljs-comment">// 消费属性值</span><br>          <span class="hljs-title function_">advanceBy</span>(value.<span class="hljs-property">length</span>)<br>          <span class="hljs-comment">// 消费引号</span><br>          <span class="hljs-title function_">advanceBy</span>(<span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;context.source&#125;</span>: Missing quote`</span>)<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 属性值没有被引号引用</span><br>        <span class="hljs-keyword">const</span> match = <span class="hljs-regexp">/^[^\t\r\n\f &gt;]+/</span>.<span class="hljs-title function_">exec</span>(context.<span class="hljs-property">source</span>)<br>        <span class="hljs-keyword">if</span> (match) &#123;<br>          <span class="hljs-comment">// 获取属性值</span><br>          value = match[<span class="hljs-number">0</span>]<br>          <span class="hljs-comment">// 消费属性值</span><br>          <span class="hljs-title function_">advanceBy</span>(value.<span class="hljs-property">length</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;context.source&#125;</span> can not match.`</span>)<br>        &#125;<br>        <br>      &#125;<br>      <br>      <span class="hljs-comment">// 消费空白字符</span><br>      <span class="hljs-title function_">advanceSpaces</span>()<br>      <br>      <span class="hljs-comment">// 创建属性节点，添加到props中</span><br>      props.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Attribute&#x27;</span>,<br>        name,<br>        value<br>      &#125;)<br>      <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;context.source&#125;</span> can not match.`</span>)<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后修改<code>parseTag</code>以支持属性的解析：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">parseTag</span>(<span class="hljs-params"><span class="hljs-attr">context</span>: parseCtx, <span class="hljs-keyword">type</span> = <span class="hljs-string">&#x27;start&#x27;</span></span>): <span class="hljs-title class_">AstNode</span> | <span class="hljs-literal">undefined</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; advanceBy, advanceSpaces &#125; = context<br><br>  <span class="hljs-comment">// 处理开始标签和结束标签</span><br>  <span class="hljs-keyword">const</span> match = <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;start&#x27;</span><br>    <span class="hljs-comment">// 开始标签</span><br>    ? <span class="hljs-regexp">/^&lt;([a-z][^\t\r\n\f /&gt;]*)/i</span>.<span class="hljs-title function_">exec</span>(context.<span class="hljs-property">source</span>)<br>    <span class="hljs-comment">// 结束标签</span><br>    : <span class="hljs-regexp">/^&lt;\/([a-z][^\t\r\n\f /&gt;]*)/i</span>.<span class="hljs-title function_">exec</span>(context.<span class="hljs-property">source</span>)<br><br>  <span class="hljs-comment">// 匹配成功正则表达式第一个捕获组的值就是标签名称</span><br>  <span class="hljs-keyword">if</span> (match) &#123;<br>    <span class="hljs-keyword">const</span> tag = match[<span class="hljs-number">1</span>]<br>    <span class="hljs-comment">// 清除正则表达式匹配的全部内容</span><br>    <span class="hljs-title function_">advanceBy</span>(match[<span class="hljs-number">0</span>])<br>    <span class="hljs-title function_">advanceSpaces</span>()<br>    <br>    <span class="hljs-comment">// 获取props</span><br>    <span class="hljs-keyword">const</span> props = <span class="hljs-title function_">parseAttributes</span>(context)<br>    <br>    <span class="hljs-comment">// 如果消除后字符串以 /&gt; 开头则是自闭合标签</span><br>    <span class="hljs-keyword">const</span> isSelfClosing = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;/&gt;&quot;</span>)<br>    <span class="hljs-comment">// 如果是自闭合标签，则消费 &#x27;/&gt;&#x27;， 否则消费 &#x27;&gt;&#x27;</span><br>    <span class="hljs-title function_">advanceBy</span>(isSelfClosing ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// 返回标签节点</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Element&#x27;</span>,<br>      <span class="hljs-attr">tag</span>: tag,<br>      <span class="hljs-attr">props</span>: props,<br>      <span class="hljs-attr">children</span>: [],<br>      <span class="hljs-attr">isSelfClosing</span>: isSelfClosing<br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;tag does not match.&quot;</span>)<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="解析文本与解码html实体">解析文本与解码HTML实体</span></h2><h3><span id="解析文本">解析文本</span></h3><p>调用<code>parseText</code>函数处理文本内容。此时解析器会在模板中寻找下一个&lt;字符或插值定界符的位置索引，记为索引 I。然后，解析器会从模板的头部到索引 I 的位置截取内容，这段截取出来的字符串将作为文本节点的内容。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseText</span>(<span class="hljs-params"><span class="hljs-attr">context</span>: parseCtx</span>) &#123;<br>  <span class="hljs-comment">// endIndex为文本内容结尾索引</span><br>  <span class="hljs-comment">// 默认将整个莫欧版剩余内容都作为文本内容</span><br>  <span class="hljs-keyword">let</span> endIndex = context.<span class="hljs-property">source</span>.<span class="hljs-property">length</span><br>  <span class="hljs-comment">// 寻找 &lt; </span><br>  <span class="hljs-keyword">const</span> ltIndex = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;&lt;&#x27;</span>)<br>  <span class="hljs-comment">// 寻找 &#123;&#123;</span><br>  <span class="hljs-keyword">const</span> delimiterIndex = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&#x27;&#123;&#123;&#x27;</span>)<br>  <br>  <span class="hljs-comment">// 取 ltIndex 和当前 endIndex 中较小的作为结尾索引</span><br>  <span class="hljs-keyword">if</span> (ltIndex &gt; -<span class="hljs-number">1</span> &amp;&amp; ltIndex &lt; endIndex) &#123;<br>    endIndex = ltIndex<br>  &#125;<br>  <br>  <span class="hljs-comment">// delimiterIndex同理</span><br>  <span class="hljs-keyword">if</span> (delimiterIndex &gt; -<span class="hljs-number">1</span> &amp;&amp; delimiterIndex &lt; endIndex) &#123;<br>    endIndex = delimiterIndex<br>  &#125;<br>  <br>  <span class="hljs-keyword">const</span> content = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, endIndex)<br>  <br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Text&#x27;</span>,<br>    content<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<h3><span id="解码命名字符引用">解码命名字符引用</span></h3><p>HTML 实体是一段以字符<code>&amp;</code>开始的文本内容。实体用来描述 HTML 中的保留字符和一些难以通过普通键盘输入的字符，以及一些不可见的字符。HTML 实体总是以字符<code>&amp;</code>开头，以字符<code>;</code>结尾。之所以需要解析命名字符引用，是因为 Vue 模板中，文本节点所包含的 HTML 实体不会被浏览器解析。这是因为模板中的文本节点最终将通过如<code>el.textContent</code>等文本操作方法设置到页面，而通过<code>el.textContent</code>设置的文本内容是不会经过 HTML 实体解码的。</p>
<p>解析 HTML 实体也是一种状态机：</p>
<p><img src="https://pic.imgdb.cn/item/66d6e089d9c307b7e978afca.png"></p>
<p>关于字符引用中的分号：</p>
<ul>
<li>当存在分号时：执行完整匹配。</li>
<li>当省略分号时：执行最短匹配。</li>
</ul>
<p>为此，我们需要精心设计命名字符引用表。由于命名字符引用的数量非常多，因此这里我们只取其中一部分作为命名字符引用表的内容：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> namedCharacterReferences = &#123;<br>  <span class="hljs-string">&quot;gt&quot;</span>: <span class="hljs-string">&quot;&gt;&quot;</span>,<br>  <span class="hljs-string">&quot;gt;&quot;</span>: <span class="hljs-string">&quot;&gt;&quot;</span>,<br>  <span class="hljs-string">&quot;lt&quot;</span>: <span class="hljs-string">&quot;&lt;&quot;</span>,<br>  <span class="hljs-string">&quot;lt;&quot;</span>: <span class="hljs-string">&quot;&lt;&quot;</span>,<br>  <span class="hljs-string">&quot;ltcc;&quot;</span>: <span class="hljs-string">&quot;⪦&quot;</span> <br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于普通文本部分，由于它不需要被解码，因此索引原封不动地保留。而对于可能是字符引用的部分，执行解码工作。</p>
<ul>
<li>计算出命名字符引用表中实体名称的最大长度。</li>
<li>根据最大长度截取字符串。</li>
<li>用截取后的字符串作为键去命名字符引用表中查询对应的值，即解码。</li>
<li>当发现不匹配时，我们将最大长度减 1，并重新执行第二步，直到找到匹配项为止。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decodeHTML</span>(<span class="hljs-params"><span class="hljs-attr">rawText</span>: <span class="hljs-built_in">string</span>, asAttr = <span class="hljs-literal">false</span></span>) &#123;<br><br>  <span class="hljs-keyword">let</span> offset = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">const</span> end = rawText.<span class="hljs-property">length</span><br>  <span class="hljs-comment">// 解码后的文本</span><br>  <span class="hljs-keyword">let</span> decodedText = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-comment">// 引用表中实体名称的最大长度</span><br>  <span class="hljs-keyword">let</span> maxCRNameLength = <span class="hljs-number">0</span><br><br>  <span class="hljs-comment">// advance 函数用于消费指定长度的文本</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">advance</span>(<span class="hljs-params"><span class="hljs-attr">length</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    offset += length<br>    rawText = rawText.<span class="hljs-title function_">slice</span>(length)<br>  &#125;<br><br>  <span class="hljs-keyword">while</span> (offset &lt; end) &#123;<br>    <span class="hljs-comment">// 匹配字符串引用的开始部分</span><br>    <span class="hljs-comment">// &amp; 命名字符引用</span><br>    <span class="hljs-comment">// &amp;# 十进制数字字符引用</span><br>    <span class="hljs-comment">// &amp;#* 十六进制数字字符引用</span><br>    <span class="hljs-keyword">const</span> head = <span class="hljs-regexp">/&amp;(?:#x?)?/i</span>.<span class="hljs-title function_">exec</span>(rawText)<br>    <span class="hljs-comment">// 没有匹配则说明不需要继续解码了</span><br>    <span class="hljs-keyword">if</span> (!head) &#123;<br>      <span class="hljs-comment">// 计算剩余内容</span><br>      <span class="hljs-keyword">const</span> remain = end - offset<br>      <span class="hljs-comment">// 将剩余内容加到 decodedText 上</span><br>      decodedText += rawText.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, remain)<br>      <span class="hljs-comment">// 消费剩余内容</span><br>      <span class="hljs-title function_">advance</span>(remain)<br>      <span class="hljs-keyword">break</span><br>    &#125;<br><br>    <span class="hljs-comment">// head.index 为匹配的字符 &amp; 在 rawText 中的位置索引</span><br>    <span class="hljs-comment">// 截取字符 &amp; 之前的内容加到 decodedText 上</span><br>    decodedText += rawText.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, head.<span class="hljs-property">index</span>)<br>    <span class="hljs-comment">// 消费字符 &amp; 之前的内容</span><br>    <span class="hljs-title function_">advance</span>(head.<span class="hljs-property">index</span>)<br><br>    <span class="hljs-comment">// 如果满足条件则是命名字符引用，否则为数字字符引用</span><br>    <span class="hljs-keyword">if</span> (head[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;&amp;&#x27;</span>) &#123;<br>      <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;&#x27;</span><br>      <span class="hljs-keyword">let</span> <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span><br>      <span class="hljs-comment">// 字符 &amp; 的下一个字符必须是 ASCII 字母或数字</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/[0-9a-z]/i</span>.<span class="hljs-title function_">test</span>(rawText[<span class="hljs-number">1</span>])) &#123;<br>        <span class="hljs-comment">// 根据引用表计算实体名称的最大长度</span><br>        <span class="hljs-keyword">if</span> (!maxCRNameLength) &#123;<br>          maxCRNameLength = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(namedCharacterReferences).<span class="hljs-title function_">reduce</span>(<br>            <span class="hljs-function">(<span class="hljs-params">max, name</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-title class_">Number</span>(max), name.<span class="hljs-property">length</span>), <span class="hljs-number">0</span><br>          )<br>        &#125;<br><br>        <span class="hljs-comment">// 从最大长度开始对文本进行截取，并尝试去引用表中找到对应的项</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> length = maxCRNameLength; !value &amp;&amp; length &gt; <span class="hljs-number">0</span> ; length--) &#123;<br>          name = rawText.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>, length)<br>          value = namedCharacterReferences[name]<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (value) &#123;<br>          <span class="hljs-keyword">const</span> semi = name.<span class="hljs-title function_">endsWith</span>(<span class="hljs-string">&quot;;&quot;</span>)<br><br>          <span class="hljs-comment">// 如果解码的文本作为属性值，最后一个匹配的字符不是分号，</span><br>          <span class="hljs-comment">// 并且最后一个匹配字符的下一个字符是等于号（=）、ASCII 字母或</span><br>          <span class="hljs-comment">// 数字，</span><br>          <span class="hljs-comment">// 由于历史原因，将字符 &amp; 和实体名称 name 作为普通文本</span><br>          <span class="hljs-keyword">if</span> (asAttr &amp;&amp; !semi &amp;&amp;<br>              <span class="hljs-regexp">/[=a-z0-9]/i</span>.<span class="hljs-title function_">test</span>(rawText[name.<span class="hljs-property">length</span> + <span class="hljs-number">1</span>] || <span class="hljs-string">&#x27;&#x27;</span>)<br>          ) &#123;<br><br>            decodedText += <span class="hljs-string">&#x27;&amp;&#x27;</span> + name<br>            <span class="hljs-title function_">advance</span>(<span class="hljs-number">1</span> + name.<span class="hljs-property">length</span>)<br><br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他情况正常使用解码后的内容拼接到 decodedText</span><br>            decodedText += value<br>            <span class="hljs-title function_">advance</span>(<span class="hljs-number">1</span> + name.<span class="hljs-property">length</span>)<br>          &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 没找到对应值，解码失败</span><br>          decodedText += <span class="hljs-string">&#x27;&amp;&#x27;</span> + name<br>          <span class="hljs-title function_">advance</span>(<span class="hljs-number">1</span> + name.<span class="hljs-property">length</span>)<br>        &#125;<br><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果字符 &amp; 的下一个字符不是 ASCII 字母或数字，则将字符 &amp; 作为普通文本</span><br>        decodedText += <span class="hljs-string">&#x27;&amp;&#x27;</span><br>        <span class="hljs-title function_">advance</span>(<span class="hljs-number">1</span>)<br>      &#125;<br>    &#125;<br><br><br>  &#125;<br>  <span class="hljs-keyword">return</span> decodedText<br>&#125;<br></code></pre></td></tr></table></figure>

<h3><span id="解码数字字符引用">解码数字字符引用</span></h3><p>数字字符引用的格式是：前缀 + Unicode 码点。解码数字字符引用的关键在于，如何提取字符引用中的 Unicode 码点。考虑到数字字符引用的前缀可以是以十进制表示（&amp;#），也可以是以十六进制表示（&amp;#x），所以我们使用下面的代码来完成码点的提取：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 判断十进制还是十六进制</span><br><span class="hljs-keyword">const</span> hex = head[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;&amp;#x&#x27;</span><br><span class="hljs-keyword">const</span> pattern = hex ? <span class="hljs-regexp">/^&amp;#x([0-9a-f]+);?/i</span> : <span class="hljs-regexp">/^&amp;#([0-9]+);?/i</span><br><br><span class="hljs-comment">// body[1] 的值就是 Unicode 码点</span><br><span class="hljs-keyword">const</span> body = pattern.<span class="hljs-title function_">exec</span>(rawText)<br><span class="hljs-comment">// 调用 String.fromCodePoint 解码</span><br><span class="hljs-keyword">if</span> (body) &#123;<br>    <span class="hljs-keyword">const</span> cp = <span class="hljs-built_in">parseInt</span>(body[<span class="hljs-number">1</span>], hex ? <span class="hljs-number">16</span> : <span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">const</span> char = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(cp)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在真正进行解码前，需要对码点的值进行合法性检查，这里就不做过多叙述了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span> (body) &#123;<br>    <span class="hljs-keyword">let</span> cp = <span class="hljs-built_in">parseInt</span>(body[<span class="hljs-number">1</span>], hex ? <span class="hljs-number">16</span> : <span class="hljs-number">10</span>)<br>    <br>    <span class="hljs-comment">// 检查合法性</span><br>    <span class="hljs-keyword">if</span> (cp === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果码点值为 0x00，替换为 0xfffd</span><br>        cp = <span class="hljs-number">0xfffd</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cp &gt; <span class="hljs-number">0x10ffff</span>) &#123;<br>        <span class="hljs-comment">// 如果码点值超过 Unicode 的最大值，替换为 0xfffd</span><br>        cp = <span class="hljs-number">0xfffd</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cp &gt;= <span class="hljs-number">0xd800</span> &amp;&amp; cp &lt;= <span class="hljs-number">0xdfff</span>) &#123;<br>        <span class="hljs-comment">// 如果码点值处于代理对 surrogate pair 范围内，替换为 0xfffd</span><br>        cp = <span class="hljs-number">0xfffd</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((cp &gt;= <span class="hljs-number">0xfdd0</span> &amp;&amp; cp &lt;= <span class="hljs-number">0xfdef</span>) || (cp &amp; <span class="hljs-number">0xfffe</span>) === <span class="hljs-number">0xfffe</span>) &#123;<br>        <span class="hljs-comment">// 如果码点值处于 noncharacter 范围内，则什么都不做，交给平台处理</span><br>        <span class="hljs-comment">// noncharacter 代表 Unicode 永久保留的码点，用于 Unicode 内部</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>    	<span class="hljs-comment">// 控制字符集的范围是：[0x01, 0x1f] 加上 [0x7f, 0x9f]</span><br>        <span class="hljs-comment">// 去掉 ASICC 空白符：0x09(TAB)、0x0A(LF)、0x0C(FF)</span><br>        <span class="hljs-comment">// 0x0D(CR) 虽然也是 ASICC 空白符，但需要包含</span><br>        (cp &gt;= <span class="hljs-number">0x01</span> &amp;&amp; cp &lt;= <span class="hljs-number">0x08</span>) || cp === <span class="hljs-number">0x0b</span> ||<br>        (cp &gt;= <span class="hljs-number">0x0d</span> &amp;&amp; cp &lt;= <span class="hljs-number">0x1f</span>) || (cp &gt;= <span class="hljs-number">0x7f</span> &amp;&amp; cp &lt;= <span class="hljs-number">0x9f</span>)<br>    ) &#123;<br>        <span class="hljs-comment">// 在 CCR_REPLACEMENTS 表中查找替换码点，如果找不到，则使用原码点</span><br>        cp = <span class="hljs-variable constant_">CCR_REPLACEMENTS</span>[cp] || cp<br>    &#125;<br>    <span class="hljs-comment">// 最后进行解码</span><br>    <span class="hljs-keyword">const</span> char = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(cp)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们将上述代码整合到 decodeHtml 函数中，这样就实现一个完善的 HTML 文本解码函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">decodeHTML</span>(<span class="hljs-params"><span class="hljs-attr">rawText</span>: <span class="hljs-built_in">string</span>, asAttr = <span class="hljs-literal">false</span></span>) &#123;<br><br> 	...<br><br>  <span class="hljs-keyword">while</span> (offset &lt; end) &#123;<br>    ...<br><br>    <span class="hljs-comment">// 如果满足条件则是命名字符引用，否则为数字字符引用</span><br>    <span class="hljs-keyword">if</span> (head[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;&amp;&#x27;</span>) &#123;<br>        <br>      ...<br>      <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 判断十进制还是十六进制</span><br>      <span class="hljs-keyword">const</span> hex = head[<span class="hljs-number">0</span>] === <span class="hljs-string">&#x27;&amp;#x&#x27;</span><br>      <span class="hljs-keyword">const</span> pattern = hex ? <span class="hljs-regexp">/^&amp;#x([0-9a-f]+);?/i</span> : <span class="hljs-regexp">/^&amp;#([0-9]+);?/i</span><br><br>      <span class="hljs-comment">// body[1] 的值就是 Unicode 码点</span><br>      <span class="hljs-keyword">const</span> body = pattern.<span class="hljs-title function_">exec</span>(rawText)<br>      <span class="hljs-comment">// 调用 String.fromCodePoint 解码</span><br>      <span class="hljs-keyword">if</span> (body) &#123;<br>        <span class="hljs-keyword">let</span> cp = <span class="hljs-built_in">parseInt</span>(body[<span class="hljs-number">1</span>], hex ? <span class="hljs-number">16</span> : <span class="hljs-number">10</span>)<br><br>        <span class="hljs-comment">// 检查合法性</span><br>        <span class="hljs-keyword">if</span> (cp === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果码点值为 0x00，替换为 0xfffd</span><br>            cp = <span class="hljs-number">0xfffd</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cp &gt; <span class="hljs-number">0x10ffff</span>) &#123;<br>            <span class="hljs-comment">// 如果码点值超过 Unicode 的最大值，替换为 0xfffd</span><br>            cp = <span class="hljs-number">0xfffd</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cp &gt;= <span class="hljs-number">0xd800</span> &amp;&amp; cp &lt;= <span class="hljs-number">0xdfff</span>) &#123;<br>            <span class="hljs-comment">// 如果码点值处于代理对 surrogate pair 范围内，替换为 0xfffd</span><br>            cp = <span class="hljs-number">0xfffd</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((cp &gt;= <span class="hljs-number">0xfdd0</span> &amp;&amp; cp &lt;= <span class="hljs-number">0xfdef</span>) || (cp &amp; <span class="hljs-number">0xfffe</span>) === <span class="hljs-number">0xfffe</span>) &#123;<br>            <span class="hljs-comment">// 如果码点值处于 noncharacter 范围内，则什么都不做，交给平台处理</span><br>            <span class="hljs-comment">// noncharacter 代表 Unicode 永久保留的码点，用于 Unicode 内部</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<br>          <span class="hljs-comment">// 控制字符集的范围是：[0x01, 0x1f] 加上 [0x7f, 0x9f]</span><br>            <span class="hljs-comment">// 去掉 ASICC 空白符：0x09(TAB)、0x0A(LF)、0x0C(FF)</span><br>            <span class="hljs-comment">// 0x0D(CR) 虽然也是 ASICC 空白符，但需要包含</span><br>            (cp &gt;= <span class="hljs-number">0x01</span> &amp;&amp; cp &lt;= <span class="hljs-number">0x08</span>) || cp === <span class="hljs-number">0x0b</span> ||<br>            (cp &gt;= <span class="hljs-number">0x0d</span> &amp;&amp; cp &lt;= <span class="hljs-number">0x1f</span>) || (cp &gt;= <span class="hljs-number">0x7f</span> &amp;&amp; cp &lt;= <span class="hljs-number">0x9f</span>)<br>        ) &#123;<br>            <span class="hljs-comment">// 在 CCR_REPLACEMENTS 表中查找替换码点，如果找不到，则使用原码点</span><br>            cp = <span class="hljs-variable constant_">CCR_REPLACEMENTS</span>[cp] || cp<br>        &#125;<br>        <span class="hljs-comment">// 最后进行解码，追加到 decodedText 上</span><br>        <span class="hljs-keyword">const</span> char = <span class="hljs-title class_">String</span>.<span class="hljs-title function_">fromCodePoint</span>(cp)<br>        decodedText += char<br><br>        <span class="hljs-comment">// 消费整个数字字符引用的内容</span><br>        <span class="hljs-title function_">advance</span>(body[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>)<br><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果没有匹配，则不进行解码操作，只是把 head[0] 追加到decodedText 上并消费</span><br>        decodedText += head[<span class="hljs-number">0</span>]<br>        <span class="hljs-title function_">advance</span>(head[<span class="hljs-number">0</span>].<span class="hljs-property">length</span>)<br>      &#125;<br>    &#125;<br><br><br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> decodedText<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="解析插值与注释">解析插值与注释</span></h2><p>文本插值是 Vue.js 模板中用来渲染动态数据的常用方法，默认情况下，插值以字符串  结尾。我们通常将这两个特殊的字符串称为定界符。定界符中间的内容可以是任意合法的 JavaScript 表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&#123;&#123; obj.fn() &#125;&#125;<br></code></pre></td></tr></table></figure>

<p>解析器在解析插值时，只需要将文本插值的开始定界符与结束定界符之间的内容提取出来，作为 JavaScript 表达式即可。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseInterpolation</span>(<span class="hljs-params"><span class="hljs-attr">context</span>: parseCtx</span>) &#123;<br>  <span class="hljs-comment">// 消费开始界定符号</span><br>  context.<span class="hljs-title function_">advanceBy</span>(<span class="hljs-string">&#x27;&#123;&#123;&#x27;</span>.<span class="hljs-property">length</span>)<br>  <span class="hljs-comment">// 找到结束定界符的位置索引</span><br>  <span class="hljs-keyword">const</span> closeIndex = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;&#125;&#125;&quot;</span>)<br>  <span class="hljs-keyword">if</span> (closeIndex &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;context.source&#125;</span> is lack of &#x27;&#125;&#125;&#x27;`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 截取开始定界符于结束定界符之间的内容作为插值表达式</span><br>  <span class="hljs-keyword">const</span> content = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, closeIndex)<br>  <span class="hljs-comment">// 消费表达式的内容</span><br>  context.<span class="hljs-title function_">advanceBy</span>(content.<span class="hljs-property">length</span>)<br>  <span class="hljs-comment">// 消费结束定界符</span><br>  context.<span class="hljs-title function_">advanceBy</span>(<span class="hljs-string">&quot;&#125;&#125;&quot;</span>.<span class="hljs-property">length</span>)<br><br>  <span class="hljs-comment">// 返回类型为 Interpolation 的节点，代表插值节点</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Interpolation&#x27;</span>,<br>    <span class="hljs-attr">content</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;Expression&quot;</span>,<br>      <span class="hljs-attr">content</span>: <span class="hljs-title function_">decodeHTML</span>(content)<br>    &#125;<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>解析注释的思路与解析插值非常相似：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseComment</span>(<span class="hljs-params"><span class="hljs-attr">context</span>: parseCtx</span>) &#123;<br>  <span class="hljs-comment">// 消费注释的开始部分</span><br>  context.<span class="hljs-title function_">advanceBy</span>(<span class="hljs-string">&#x27;&lt;!--&#x27;</span>.<span class="hljs-property">length</span>)<br>  <span class="hljs-comment">// 找到结束索引</span><br>  <span class="hljs-keyword">const</span> closeIndex = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">&quot;--&gt;&quot;</span>)<br>  <span class="hljs-keyword">if</span> (closeIndex &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;context.source&#125;</span> is lack of &#x27;--&gt;&#x27;`</span>)<br>  &#125;<br>  <span class="hljs-comment">// 截取开始定界符于结束定界符之间的内容作为注释内容</span><br>  <span class="hljs-keyword">const</span> content = context.<span class="hljs-property">source</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, closeIndex)<br>  <span class="hljs-comment">// 消费表达式的内容</span><br>  context.<span class="hljs-title function_">advanceBy</span>(content.<span class="hljs-property">length</span>)<br>  <span class="hljs-comment">// 消费结束定界符</span><br>  context.<span class="hljs-title function_">advanceBy</span>(<span class="hljs-string">&quot;--&gt;&quot;</span>.<span class="hljs-property">length</span>)<br><br>  <span class="hljs-comment">// 返回类型为 Interpolation 的节点，代表插值节点</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;Comment&#x27;</span>,<br>    content<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1><span id="编译优化">编译优化</span></h1><p>编译优化指的是编译器将模板编译为渲染函数的过程中，尽可能多地提取关键信息，并以此指导生成最优代码的过程。优化的方向基本一致，即尽可能地区分动态内容和静态内容，并针对不同的内容采用不同的优化策略。</p>
<h2><span id="动态节点收集与补丁标志">动态节点收集与补丁标志</span></h2><h3><span id="传统-diff-算法的问题">传统 Diff 算法的问题</span></h3><p>无论哪一种 Diff 算法，当它在比对新旧两棵虚拟 DOM 树的时候，总是要按照虚拟 DOM 的层级结构“一层一层”地遍历。但是我们会发现，在有些模板中并不是所有的 DOM 节点都会发生变化，因此传统 diff 算法存在很多无意义的对比操作。</p>
<p>通过编译手段，我们可以分析出很多关键信息，例如哪些节点是静态的，哪些节点是动态的。为什么虚拟 DOM 会产生额外的性能开销呢？根本原因在于，渲染器在运行时得不到足够的信息。传统 Diff 算法无法利用编译时提取到的任何关键信息，这导致渲染器在运行时不可能去做相关的优化。而 Vue.js 3 的编译器会将编译时得到的关键信息“附着”在它生成的虚拟 DOM 上，这些信息会通过虚拟 DOM 传递给渲染器。最终，渲染器会根据这些关键信息执行“快捷路径”，从而提升运行时的性能。</p>
<h3><span id="block与patchflags"><code>Block</code>与<code>PatchFlags</code></span></h3><p>只要运行时能够区分动态内容和静态内容，即可实现极致的优化策略。对于动态节点，我们为它加上一个额外的属性补丁标志<code>patchFlag</code>。我们可以把补丁标志理解为一系列数字标记，并根据数字值的不同赋予它不同的含义，示例如下：</p>
<ul>
<li>数字 1 ：代表节点有动态的 <code>textContent</code> </li>
<li>数字 2 ：代表元素有动态的 <code>class</code> 绑定</li>
<li>数字 3 ： 代表元素有动态的 <code>style</code> 绑定</li>
<li>数字 4 ： …</li>
</ul>
<p>有了这项信息，我们就可以在虚拟节点的创建阶段，把它的动态子节点提取出来，并将其存储到该虚拟节点的<code>dynamicChildren</code>数组内，我们把带有该属性<code>dynamicChildren</code>数组的虚拟节点称为“块”（<code>Block</code>）。一个<code>Block</code>不仅能够收集它的直接动态子节点，还能够收集所有动态子代节点。</p>
<p>有了<code>Block</code>这个概念之后，渲染器的更新操作将会以<code>Block</code>为维度。也就是说，当渲染器在更新一个<code>Block</code>时，会忽略虚拟节点的<code>children</code>数组，而是直接找到该虚拟节点的<code>dynamicChildren</code>数组，并只更新该数组中的动态节点。同时，由于动态节点中存在对应的补丁标志，所以在更新动态节点的时候，也能够做到靶向更新。</p>
<p>当我们在编写模板代码的时候，所有模板的根节点都会是一个<code>Block</code>节点，带指令的节点也需要作为<code>Block</code>节点。</p>
<h3><span id="收集动态节点">收集动态节点</span></h3><p>在编译器生成的渲染函数代码中，并不会直接包含用来描述虚拟节点的数据结构，而是包含着用来创建虚拟 DOM 节点的辅助函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createVNode</span>(...)<br>&#125;<br>                       <br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createVNode</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">tag</span>: <span class="hljs-built_in">string</span>, </span><br><span class="hljs-params">  <span class="hljs-attr">props</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;, </span><br><span class="hljs-params">  <span class="hljs-attr">children</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">any</span>&gt;, </span><br><span class="hljs-params">  patchFlag?: <span class="hljs-built_in">boolean</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> key = props &amp;&amp; props.<span class="hljs-property">key</span><br>  props &amp;&amp; <span class="hljs-keyword">delete</span> props.<span class="hljs-property">key</span><br>        <br>  <span class="hljs-keyword">return</span> &#123;<br>    tag,<br>    props,<br>    children,<br>    key<br>  &#125;<br>&#125;                   <br></code></pre></td></tr></table></figure>

<p>当外层<code>createVNode</code>函数执行时，内层的<code>createVNode</code>函数已经执行完毕了。因此，为了让外层<code>Block</code>节点能够收集到内层动态节点，就需要一个栈结构的数据来临时存储内层的动态节点：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 动态节点栈</span><br><span class="hljs-keyword">const</span> dynamicChildrenStack = []<br><span class="hljs-comment">// 当前动态节点集合</span><br><span class="hljs-keyword">let</span> currentDynamicChildren = <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建动态节点集合并压栈</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">openBlock</span>(<span class="hljs-params"></span>) &#123;<br>  dynamicChildrenStack.<span class="hljs-title function_">push</span>((currentDynamicChildren = []))<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过 openBlock 创建的动态节点集合从栈中弹出</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">closeBlock</span>(<span class="hljs-params"></span>) &#123;<br>  currentDynamicChildren = dynamicChildrenStack.<span class="hljs-title function_">pop</span>()<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createVNode</span>(<span class="hljs-params"></span><br><span class="hljs-params">  tag,</span><br><span class="hljs-params">  props,</span><br><span class="hljs-params">  children,</span><br><span class="hljs-params">  patchFlag</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> key = props &amp;&amp; props.<span class="hljs-property">key</span><br>  props &amp;&amp; <span class="hljs-keyword">delete</span> props.<span class="hljs-property">key</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">vnode</span>: <span class="hljs-title class_">Block</span> = &#123;<br>    tag,<br>    props,<br>    children,<br>    key,<br>    <span class="hljs-title class_">PatchFlag</span>: patchFlag<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> patchFlag !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; currentDynamicChildren) &#123;<br>    currentDynamicChildren.<span class="hljs-title function_">push</span>(vnode)<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> vnode<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<code>createVNode</code>函数内部，检测节点是否存在补丁标志。如果存在，则说明该节点是动态节点，于是将其添加到当前动态节点集合。我们还需要重新设计渲染函数的执行方式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;div&gt;</span><br><span class="hljs-comment">	&lt;div&gt;&#123;&#123; foo &#125;&#125;&lt;/div&gt;</span><br><span class="hljs-comment">	&lt;p&gt; bar &lt;/p&gt;</span><br><span class="hljs-comment">&lt;/div&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 使用 createBlock 代替 createVNode 来创建根节点 block</span><br>    <span class="hljs-comment">// 每当调用 createBlock 之前，先调用 openBlock</span><br>	<span class="hljs-keyword">return</span> (<span class="hljs-title function_">openBlock</span>(), <span class="hljs-title function_">createBlock</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, [<br>        <span class="hljs-title function_">createVNode</span>(<span class="hljs-string">&#x27;div&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;foo&#x27;</span>&#125;, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span><span class="hljs-comment">/*PatchFlag*/</span>),<br>        <span class="hljs-title function_">createVNode</span>(<span class="hljs-string">&#x27;p&#x27;</span>, &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;, <span class="hljs-literal">null</span>,),<br>    ])	<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createBlock</span>(<span class="hljs-params"></span><br><span class="hljs-params">  tag,</span><br><span class="hljs-params">  props,</span><br><span class="hljs-params">  children</span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> block = <span class="hljs-title function_">createVNode</span>(tag, props, children)<br>  block.<span class="hljs-property">dynamicChildren</span> = currentDynamicChildren<br><br>  <span class="hljs-comment">// 关闭 Block</span><br>  <span class="hljs-title function_">closeBlock</span>()<br>  <span class="hljs-keyword">return</span> block<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于<code>createVNode</code>函数和<code>createBlock</code>函数的执行顺序是从内向外，所以当<code>createBlock</code>数执行时，内层的所有<code>createVNode</code>函数已经执行完毕了。这时，<code>currentDynamicChildren</code>数组中所存储的就是属于当前<code>Block</code>的所有动态子代节点。</p>
<h3><span id="渲染器的运行时支持">渲染器的运行时支持</span></h3><p>在之前实现的<code>patchElement</code>函数中，渲染器在更新标签节点时，使用<code>patchChildren</code>函数来更新标签的子节点。但该函数会使用传统虚拟 DOM 的 Diff 算法进行更新，这样做效率比较低。有了<code>dynamicChildren</code>之后，我们可以直接对比动态节点。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchElement</span>(<span class="hljs-params">oldNode, newNode</span>) &#123;<br>  ...<br><br>  <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">dynamicChildren</span>) &#123;<br>    <span class="hljs-comment">// 只更新动态节点</span><br>    <span class="hljs-title function_">patchBlockChildren</span>(oldNode, newNode)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 更新子节点</span><br>    <span class="hljs-title function_">patchChildren</span>(oldNode, newNode, el)<br>  &#125;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更新动态节点</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchBlockChildren</span>(<span class="hljs-params">oldNode, newNode</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; newNode.<span class="hljs-property">dynamicChildren</span> &amp;&amp; i &lt; newNode.<span class="hljs-property">dynamicChildren</span>.<span class="hljs-property">length</span> ; i++) &#123;<br>    <span class="hljs-keyword">if</span> (oldNode.<span class="hljs-property">dynamicChildren</span>) &#123;<br>      <span class="hljs-title function_">patchElement</span>(oldNode.<span class="hljs-property">dynamicChildren</span>[i], newNode.<span class="hljs-property">dynamicChildren</span>[i])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Block does not exist.&quot;</span>)<br>      <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>动态节点集合能够使得渲染器在执行更新时跳过静态节点，但对于单个动态节点的更新来说，由于它存在对应的补丁标志，因此我们可以针对性地完成靶向更新：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">patchElement</span>(<span class="hljs-params">oldNode, newNode</span>) &#123;<br>  ...<br><br>  <span class="hljs-comment">// 靶向更新</span><br>  <span class="hljs-keyword">if</span> (newNode.<span class="hljs-property">PatchFlag</span>) &#123;<br>    <span class="hljs-keyword">const</span> flag = newNode.<span class="hljs-property">PatchFlag</span><br>    <span class="hljs-keyword">if</span> (flag === <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// 更新 Text</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag === <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-comment">// 更新 class</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flag === <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-comment">// 更新style</span><br>    &#125;<br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 全量更新props</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> newProps) &#123;<br>      <span class="hljs-keyword">if</span> (newProps[key] !== oldProps[key]) &#123;<br>        <span class="hljs-title function_">patchProps</span>(el, key, oldProps[key], newProps[key])<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将旧Props中不存在于新Props中的属性去掉</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> oldProps) &#123;<br>      <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> newProps)) &#123;<br>        <span class="hljs-title function_">patchProps</span>(el, key, oldProps[key], <span class="hljs-literal">null</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>    <br>  ...<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="block树"><code>Block</code>树</span></h2><p>带有结构化指令的节点，如带有<code>v-if</code>和<code>v-for</code>指令的节点，都应该作为<code>Block</code>角色。</p>
<h3><span id="v-if"><code>v-if</code></span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div&gt;<br>	&lt;section v-if=&#x27;foo&#x27;&gt;<br>    	&lt;p&gt;<br>            &#123;&#123; a &#125;&#125;<br>        &lt;/p&gt;<br>    &lt;/section&gt;<br>    &lt;div v-else&gt;<br>        &lt;p&gt;<br>            &#123;&#123; a &#125;&#125;<br>        &lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p><code>dynamicChildren</code>数组中收集的动态节点是忽略虚拟 DOM 树层级的。换句话说，结构化指令会导致更新前后模板的结构发生变化，即模板结构不稳定。我们也需要让带有<code>v-if/v-else-if/v-else</code>等结构化指令的节点作为<code>Block</code>角色即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Block(Div)<br>	- Block(Section v-if)<br>	- Block(Div v-else)<br></code></pre></td></tr></table></figure>

<p>父级<code>Block</code>除了会收集动态子代节点之外，也会收集子<code> Block</code>。因此，两个子<code>Block(section)</code>将作为父级<code>Block(div)</code>的动态节点被收集到父级<code>Block(div)</code>的<code>dynamicChildren</code>数组中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> block = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>    <span class="hljs-attr">dynamicChildren</span>: [<br>        <span class="hljs-comment">/* Block(Section v-if) 或 Block(Section v-else)*/</span><br>        &#123;<br>            <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;section&#x27;</span>, <br>            &#123;key : <span class="hljs-number">0</span>&#125;,<br>        	<span class="hljs-attr">dynamicChildren</span>: [...]<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当<code>v-if</code>条件为真时，父级<code>Block</code>的<code> dynamicChildren</code>数组中包含的是<code> Block(section v-if)</code>；当<code>v-if</code>的条件为假时，父级<code>Block</code>的<code>dynamicChildren</code>数组中包含的将是<code> Block(section v-else)</code>。在 Diff 过程中，渲染器能够根据<code>Block</code>的<code>key</code>值区分出更新前后的两个<code>Block</code>是不同的，并使用新的<code> Block</code>替换旧的<code> Block</code>。这样就解决了 DOM 结构不稳定引起的更新问题。</p>
<h3><span id="v-for"><code>v-for</code></span></h3><p>对于如下模板：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div&gt;<br>    &lt;p v-for=&quot;item in list&quot;&gt;<br>        &#123;&#123; item &#125;&#125;<br>    &lt;/p&gt;<br>    &lt;i&gt;<br>    	&#123;&#123; foo &#125;&#125;<br>    &lt;/i&gt;<br>    &lt;i&gt;<br>    	&#123;&#123; bar &#125;&#125;<br>    &lt;/i&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>由于传统 Diff 的一个非常重要的前置条件是：进行 Diff 操作的节点必须是同层级节点。但是<code>dynamicChildren </code>数组内的节点未必是同层级的。解决方法很简单，我们只需要让带有 v-for 指令的标签也作为 Block 角色即可。这样就能够保证虚拟 DOM 树具有稳定的结构，即无论 v-for 在运行时怎样变化，这棵 Block 树看上去都是一样的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> block = &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>    <span class="hljs-attr">dynamicChildren</span>: [<br>        &#123; <span class="hljs-attr">tag</span>: <span class="hljs-title class_">Fragment</span>, <span class="hljs-attr">dynamicChildren</span>: [<span class="hljs-comment">/* v-for 的节点*/</span>] &#125;，<br>        &#123; <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-attr">children</span>: ctx.<span class="hljs-property">foo</span>, <span class="hljs-number">1</span><span class="hljs-comment">/* TEXT */</span> &#125;,<br>        &#123; <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-attr">children</span>: ctx.<span class="hljs-property">bar</span>, <span class="hljs-number">1</span><span class="hljs-comment">/* TEXT */</span> &#125;,<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于<code>v-for</code>指令渲染的是一个片段，所以我们需要使用类型为<code>Fragment</code>的节点来表达<code>v-for</code>指令的渲染结果，并作为 Block 角色。</p>
<h3><span id="fragment稳定性"><code>Fragment</code>稳定性</span></h3><p>所谓结构不稳定，从结果上看，指的是更新前后一个 block 的<code> dynamicChildren</code>数组中收集的动态节点的数量或顺序不一致。其实对于这种情况，没有更好的解决办法，我们只能放弃根据<code>dynamicChildren</code>数组中的动态节点进行靶向更新的思路，并回退到传统虚拟 DOM 的 Diff 手段，即直接使用<code>Fragment</code>的<code>children</code>而非<code>dynamicChildren</code>来进行 Diff 操作。</p>
<p>但需要注意的是，<code>Fragment</code>的子节点（children）仍然可以是由 Block 组成的数组</p>
<p>而对于稳定的<code>Fragment</code>：</p>
<ul>
<li>v-for 指令的表达式是常量</li>
<li>模板中有多个根节点。同时，用于描述具有多个根节点的模板的<code>Fragment</code>也是稳定的。</li>
</ul>
<h2><span id="静态提升">静态提升</span></h2><p>静态提升，即把纯静态的节点提升到渲染函数之外，能够减少更新时创建虚拟 DOM 带来的性能开销和内存占用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 把静态节点提升到渲染函数之外</span><br><span class="hljs-keyword">const</span> hoist1 = <span class="hljs-title function_">createVNode</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;text&#x27;</span>)<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">return</span> (<span class="hljs-title function_">openBlock</span>(), <span class="hljs-title function_">createBlock</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, [<br>        hoist1,<br>        <span class="hljs-title function_">createVNode</span>(<span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-literal">null</span>, ctx.<span class="hljs-property">title</span>, <span class="hljs-number">1</span><span class="hljs-comment">/* TEXT */</span>)<br>    ]))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态提升是以树为单位的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div&gt;<br>    &lt;section&gt;<br>    	&lt;p&gt;<br>            &lt;span&gt; abc &lt;/span&gt;<br>        &lt;/p&gt;<br>    &lt;/section&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>在上面这段模板中，除了根节点会作为Block角色不可提升之外，整个<code>section</code>元素及其子节点都会被提升，如果把上面模板中的静态字符串<code>abc</code>换成动态绑定的<code> &#123;&#123; abc &#125;&#125;</code>，那么整棵树都不会被提升。</p>
<p>虽然包含动态绑定的节点本身不会被提升，但是该动态节点上仍然可能存在纯静态的属性。遇到静态属性时，可以把它们提升到渲染函数之外：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;div&gt;</span><br><span class="hljs-comment">	&lt;p foo=&#x27;bar&#x27; a=b&gt; &#123;&#123; text &#125;&#125; &lt;/p&gt;</span><br><span class="hljs-comment">&lt;/div&gt;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 静态提升的 props 对象  </span><br><span class="hljs-keyword">const</span> hoistProp = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;<br><br>functiono <span class="hljs-title function_">render</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-title function_">openBlock</span>(), <span class="hljs-title function_">createBlock</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, [<br>        <span class="hljs-title function_">createVNode</span>(<span class="hljs-string">&#x27;p&#x27;</span>, hoistProp, ctx.<span class="hljs-property">text</span>)<br>    ]))<br>&#125;<br></code></pre></td></tr></table></figure>

<h2><span id="预字符串化">预字符串化</span></h2><p>假设模板中包含大量连续纯静态的标签节点，当采用了静态提升优化策略后，预字符串化能够将这些静态节点序列化为字符串，并生成一个<code>Static</code>类型的<code> VNode</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> hoistStatic = <span class="hljs-title function_">createStaticVNode</span>(<span class="hljs-string">&#x27;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&#x27;</span>)<br><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-title function_">openBlock</span>(), <span class="hljs-title function_">createBlock</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, [<br>        hoistStatic<br>    ]))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这么做有几个明显的优势：</p>
<ul>
<li>大块的静态内容可以通过 innerHTML 进行设置，在性能上具有一定优势。</li>
<li>减少创建虚拟节点产生的性能开销。</li>
<li>减少内存占用。</li>
</ul>
<h2><span id="缓存内联事件处理函数">缓存内联事件处理函数</span></h2><p>缓存内联事件处理函数可以避免不必要的更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;Comp @change=&#x27;a+b&#x27;/&gt;<br></code></pre></td></tr></table></figure>

<p>对于这样的模板，编译器会为其创建一个内联事件处理函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">Comp</span>, &#123;<br>        <span class="hljs-comment">// 内联时间处理函数</span><br>        <span class="hljs-attr">onChange</span>: <span class="hljs-function">() =&gt;</span> (ctx.<span class="hljs-property">a</span> + ctx.<span class="hljs-property">b</span>)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>每次重新渲染时（即 render 函数重新执行时），都会为 Comp 组件创建一个全新的<code>props</code>对象。同时，<code>props</code>对象中<code>onChange</code>属性的值也会是全新的函数。这会导致渲染器对<code>Comp</code>组件进行更新，造成额外的性能开销。为了避免这类无用的更新，我们需要对内联事件处理函数进行缓存：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">ctx</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">Comp</span>, &#123;<br>        <span class="hljs-comment">// 内联时间处理函数</span><br>        <span class="hljs-attr">onChange</span>: <span class="hljs-function">() =&gt;</span> cache[<span class="hljs-number">0</span>] || <br>        (cache[<span class="hljs-number">0</span>] = <span class="hljs-function">(<span class="hljs-params">$event</span>) =&gt;</span> (ctx.<span class="hljs-property">a</span> + ctx.<span class="hljs-property">b</span>))<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，当渲染函数重新执行并创建新的虚拟 DOM 树时，会优先读取缓存中的事件处理函数。无论执行多少次渲染函数，<code>props</code>对象中<code>onChange</code>属性的值始终不变，于是就不会触发 Comp 组件更新了。</p>
<h2><span id="v-once"><code>v-once</code></span></h2><p>配合<code>v-once </code>还可实现对虚拟 DOM 的缓存。当编译器遇到<code> v-once</code>指令时，会利用我们上一节介绍的<code>cache</code>数组来缓存渲染函数的全部或者部分执行结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;section&gt;<br>	&lt;div v-once&gt;<br>        &#123;&#123; foo &#125;&#125;<br>    &lt;/div&gt;<br>&lt;/section&gt;<br></code></pre></td></tr></table></figure>

<p>函数重新执行时，会优先读取缓存的内容，而不会重新创建虚拟节点。同时，由于虚拟节点被缓存，意味着更新前后的虚拟节点不会发生变化，因此也就不需要这些被缓存的虚拟节点参与 Diff 操作了。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">render</span>(<span class="hljs-params">ctx, cache</span>) &#123;<br>	<span class="hljs-keyword">return</span> (<span class="hljs-title function_">openBlock</span>(), <span class="hljs-title function_">createBlock</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, [<br>        cache[<span class="hljs-number">1</span>] || (<br>        	<span class="hljs-title function_">setBlockTracking</span>(-<span class="hljs-number">1</span>),	<span class="hljs-comment">// 阻止这段 VNode 被 Block 收集</span><br>            cache[<span class="hljs-number">1</span>] = <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-literal">null</span>, ctx.<span class="hljs-property">foo</span>, <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span> ),<br>            <span class="hljs-title function_">setBlockTracking</span>(<span class="hljs-number">1</span>),	<span class="hljs-comment">// 恢复</span><br>            cache[<span class="hljs-number">1</span>]				<span class="hljs-comment">// 整个表达式的值</span><br>    ]))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这段代码中的<code>setBlockTracking(-1)</code>函数调用，它用来暂停动态节点的收集。换句话说，使用<code>v-once</code>包裹的动态节点不会被父级<code>Block</code>收集。因此，被<code>v-once</code>包裹的动态节点在组件更新时，自然不会参与<code>Diff</code>操作。</p>
<p>v-once 指令通常用于不会发生改变的动态绑定中，为了提升性能，我们可以使用<code>v-once</code>来标记，这样，在组件更新时就会跳过这段内容的更新，从而提升更新性能：</p>
<ul>
<li>避免组件更新时重新创建虚拟 DOM 带来的性能开销。因为虚拟 DOM 被缓存了，所以更新时无须重新创建。</li>
<li>避免无用的 Diff 开销。这是因为被 v-once 标记的虚拟 DOM 树不会被父级 Block 节点收集。</li>
</ul>
<h1><span id="总结">总结</span></h1><p>Vue.js 的模板编译器用于把模板编译为渲染函数。它的工作流程大致分为三个步骤：</p>
<ul>
<li>分析模板，将其解析为模板 AST。</li>
<li>将模板 AST 转换为用于描述渲染函数的 JavaScript AST。</li>
<li>根据 JavaScript AST 生成渲染函数代码。</li>
</ul>

	</article>

	 
    <div class="kira-post-copyright">
        <strong>Author：</strong>破酥 | C4iN<br>
        <strong>Link：</strong><a href="https://c4in1.github.io/2024/08/30/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM-4/" title="https:&#x2F;&#x2F;c4in1.github.io&#x2F;2024&#x2F;08&#x2F;30&#x2F;MVVM&#x2F;实现一个简单的MVVM-4&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;c4in1.github.io&#x2F;2024&#x2F;08&#x2F;30&#x2F;MVVM&#x2F;实现一个简单的MVVM-4&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			      
			<!-- 先找到与当前文字相同的目录 -->
			               
			<!-- 在找到当前文章所在的 index -->
			                
			<!-- 上一篇文章 -->
			<div class="old">
				<span>上一章</span>
				<a href="/2024/08/27/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM-3/"> 实现一个简单的MVVM-3</a>
			</div>
			                          
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/MVVM/">MVVM</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/MVVM/" rel="tag">MVVM</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/Vue/" rel="tag">Vue</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	<div class="giscus"></div>
  
    <script src="https://giscus.app/client.js"
      data-repo="C4in1/BlogGitTalk"
      data-repo-id="R_kgDOMgx61Q"
      data-category="General"
      data-category-id="DIC_kwDOMgx61c4Chec4"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="light"
      data-lang="en"
      data-loading="lazy"
      crossorigin="anonymous"
      async  
    ></script>
  

	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
