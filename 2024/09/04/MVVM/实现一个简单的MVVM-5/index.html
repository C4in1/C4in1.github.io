<!DOCTYPE html>
<html 
	lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		
<link rel="stylesheet" href="/css/layout.css">

		
		<title> 实现一个简单的MVVM-5 -  C4iN&#39;s Caprice</title>
		<!-- <link rel="stylesheet" href="https://unpkg.com/mdui@1.0.2/dist/css/mdui.min.css" /> -->
		<!-- <script src="https://unpkg.com/mdui@1.0.2/dist/js/mdui.min.js"></script> -->
		
<link rel="stylesheet" href="/lib/mdui/mdui.min.css">

		
<script src="/lib/mdui/mdui.min.js"></script>

		<!-- lazyload -->
		
<script src="/lib/lazysizes.js"></script>

		<!-- smooth-scrolling -->
		
<script src="/lib/smooth-scrolling.js"></script>

		<!-- highlight -->
		
<link rel="stylesheet" href="/lib/highlight/atom-one-dark.min.css">

		
<script src="/lib/highlight/highlight.min.js"></script>

		<!-- 预置 kiraicon -->
		
<link rel="stylesheet" href="/lib/iconfont/iconfont.css">

		
		<link
			rel="shortcut icon"
			href="https://pic.imgdb.cn/item/6693875ad9c307b7e98b4288.gif"
			type="image/gif"
		/>
		
<link rel="stylesheet" href="/deps/css/APlayer.min.css">

		
		
<script src="/deps/js/APlayer.min.js"></script>
<script src="/deps/js/Meting.min.js"></script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		<div
			class="kira-background"
			style="background-image: url('https://pic.imgdb.cn/item/66b458ffd9c307b7e9aadb03.png')"
		></div>
		<div class="kira-header">
    <a
        class="kira-drawer-button mdui-ripple"
        title="导航栏"
        onclick="document.querySelector('.kira-sidebar-modal').classList.add('show');document.querySelector('.kira-sidebar#sidebar').classList.add('show');"
    >
        <i class="kirafont icon-menu"></i>
    </a>
    <a href="/" title="C4iN&#39;s Caprice">
        <img
			src="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png"
			alt="破酥 | C4iN"
		/>
    </a>
</div>
		<div class="kira-body">
			<div class="kira-sidebar" id="sidebar">
	<div class="kira-avatar mdui-ripple">
		<a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png" title="破酥 | C4iN">
			<img
				src="https://pic.imgdb.cn/item/66b45933d9c307b7e9ab0715.png"
				alt="破酥 | C4iN"
			/>
		</a>
	</div>
	<div class="kira-count">
		<div><span>文章</span>20</div>
		<div><span>标签</span>20</div>
		<div><span>分类</span>8</div>
	</div>
	<div class="kira-list">
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/"
			title="回到首页"
		>
			<i
				class="kirafont
					
						icon-home
					"
			></i>
			<div class="kira-list-item-content">
				回到首页
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/archive"
			title="文章归档"
		>
			<i
				class="kirafont
					
						icon-container
					"
			></i>
			<div class="kira-list-item-content">
				文章归档
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/about"
			title="关于本人"
		>
			<i
				class="kirafont
					
						icon-user
					"
			></i>
			<div class="kira-list-item-content">
				关于本人
			</div>
		</a>
		
		<a
			class="kira-list-item mdui-ripple false"
			href="/friends"
			title="我的朋友"
		>
			<i
				class="kirafont
					
						icon-team
					"
			></i>
			<div class="kira-list-item-content">
				我的朋友
			</div>
		</a>
		
	</div>
	<aside id="kira-sidebar">
		
			<div class="kira-widget-wrap">
	<div class="kira-widget kira-social">
		
			<a
				class="mdui-ripple"
				href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=2405544030&website=www.oicqzone.com"
				target="_blank"
				mdui-tooltip="{content: 'QQ'}"
				style="color: rgb(49, 174, 255); background-color: rgba(49, 174, 255, .1);"
			>
				<i
					class="kirafont
					
						icon-QQ
					"
				></i>
			</a>
		
			<a
				class="mdui-ripple"
				href="https://github.com/CainHappyfish/"
				target="_blank"
				mdui-tooltip="{content: 'GitHub'}"
				style="color: rgb(25, 23, 23); background-color: rgba(25, 23, 23, .15);"
			>
				<i
					class="kirafont
					
						icon-github
					"
				></i>
			</a>
		
	</div>
</div>

		
			
  <div class="kira-widget-wrap">
    <h3 class="kira-widget-title">分类</h3>
    <div class="kira-widget">
      <ul class="category-list">
        
        

        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/MVVM/">
              MVVM
            </a>
            <span class="category-list-count">7</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/TypeScript/">
              TypeScript
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/Vue/">
              Vue
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/leetcode刷题/">
              leetcode刷题
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/project/">
              project
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/vitepress/">
              vitepress
            </a>
            <span class="category-list-count">2</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/面筋/">
              面筋
            </a>
            <span class="category-list-count">1</span>
          </li>
        
          <li class="category-list-item">
            <a class="category-list-link" href="/categories/项目构建/">
              项目构建
            </a>
            <span class="category-list-count">3</span>
          </li>
        
      </ul>
    </div>
  </div>

		
			
	<div class="kira-widget-wrap">
		<div id="randomtagcloud" class="kira-widget tagcloud kira-rainbow">
			<a href="/tags/AI-chat/" style="font-size: 10px;">AI-chat</a> <a href="/tags/ES6/" style="font-size: 10px;">ES6</a> <a href="/tags/Electron/" style="font-size: 10px;">Electron</a> <a href="/tags/MVVM/" style="font-size: 18px;">MVVM</a> <a href="/tags/TypeScript/" style="font-size: 16px;">TypeScript</a> <a href="/tags/Typescript/" style="font-size: 10px;">Typescript</a> <a href="/tags/Vitepress/" style="font-size: 12px;">Vitepress</a> <a href="/tags/Vue/" style="font-size: 18px;">Vue</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/html/" style="font-size: 10px;">html</a> <a href="/tags/leetcode/" style="font-size: 12px;">leetcode</a> <a href="/tags/theme-censored/" style="font-size: 12px;">theme-censored</a> <a href="/tags/vue3/" style="font-size: 14px;">vue3</a> <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/" style="font-size: 10px;">代码规范</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 20px;">前端</a> <a href="/tags/%E7%97%9B%E8%8B%A6%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" style="font-size: 12px;">痛苦的配置问题</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 12px;">算法</a> <a href="/tags/%E9%9D%A2%E7%AD%8B/" style="font-size: 10px;">面筋</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83/" style="font-size: 10px;">项目规范</a>
		</div>
		
	</div>


		
			
	<div class="kira-widget-wrap">
		<h3 class="kira-widget-title">
			Archive
		</h3>
		<div class="kira-widget">
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">20</span></li></ul>
		</div>
	</div>


		
	</aside>
	<div class="kira-copyright">
		&copy; 2024
		<a href="/">破酥 | C4iN</a>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> &
		<a href="https://github.com/ch1ny/kira-hexo/" target="_blank">Kira-Hexo</a>
		<br />
		
		<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><div><span id="busuanzi_container_site_uv">共接待访客<span id="busuanzi_value_site_uv"></span>位</span></div>
	</div>
</div>
<div
	class="kira-sidebar-modal"
	id="sidebar-modal"
	onclick="(function(self) {
		self.classList.remove('show');
		document.querySelector('.kira-sidebar.show#sidebar').classList.remove('show');
	})(this)"
></div>
			<div class="kira-content">
				<div id="kira-top-header"></div>
				<div class="kira-main-content">
					
<link rel="stylesheet" href="/css/kira-image.css">


<script src="/js/kira-image.js"></script>

<div class="kira-image">
    <div class="kira-image-modal">
        <div class="kira-image-header">
            <div class="kira-image-counter"></div>
            <div class="kira-image-title"></div>
            <div class="kira-image-operation">
                <div class="kira-image-operation-button" id="kira-image-operation-button-zoom">
                    <i class="kirafont icon-zoom-in"></i>
                </div>
                <div class="kira-image-operation-button" id="kira-image-operation-button-close">
                    <i class="kirafont icon-close"></i>
                </div>
            </div>
        </div>
        <div class="kira-image-container">
            <div class="kira-image-prev-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-left"></i>
                </div>
            </div>
            <div class="kira-image-list">
                <div class="kira-image-prev">
                    <img />
                </div>
                <div class="kira-image-now">
                    <img />
                </div>
                <div class="kira-image-next">
                    <img />
                </div>
            </div>
            <div class="kira-image-next-button-panel">
                <div class="kira-image-exchange-button">
                    <i class="kirafont icon-right"></i>
                </div>
            </div>
        </div>
    </div>
</div>

	
<link rel="stylesheet" href="/css/kira-code-copy.css">

	
<script src="/js/kira-code-copy.js"></script>


<div class="kira-post">
	<article>
		
		<div class="kira-post-cover">
			<img
				data-src="https://pic.imgdb.cn/item/66b47385d9c307b7e9d0b377.png"
				data-sizes="auto"
				alt="实现一个简单的MVVM-5"
				class="lazyload kira-post-cover-image disabled-kira-image"
			/>
			<h1>实现一个简单的MVVM-5</h1>
		</div>
		
		<div class="kira-post-meta kira-rainbow" style="margin:10px 0!important;">
			<a><i class="kirafont icon-calendar-fill"></i>2024年09月04日</a>
			<a><i class="kirafont icon-edit-fill"></i>6.4k 字</a>
			<a><i class="kirafont icon-time-circle-fill"></i>大概 28 分钟</a>
		</div>
		<p>这部分我们来看服务端渲染（SSR）。</p>
<span id="more"></span>
<h1><span id="同构渲染">同构渲染</span></h1>
<p>Vue.js 可以用于构建客户端应用程序，组件的代码在浏览器中运行，并输出
DOM 元素。同时，Vue.js 还可以在 Node.js
环境中运行，它可以将同样的组件渲染为字符串并发送给浏览器。这实际上描述了
Vue.js 的两种渲染方式，即客户端渲染（client-side
rendering，CSR），以及服务端渲染（server-side rendering，SSR）。另外，
Vue.js 作为现代前端框架，不仅能够独立地进行 CSR 或
SSR，还能够将两者结合，形成所谓的同构渲染（isomorphic rendering）。</p>
<h2><span id="csr-ssr-以及同构渲染">CSR、SSR 以及同构渲染</span></h2>
<p>传统的服务端渲染：</p>
<p><img src="https://pic.imgdb.cn/item/66d859b0d9c307b7e943beac.png"></p>
<ul>
<li>用户通过浏览器请求站点。</li>
<li>服务器请求 API 获取数据。</li>
<li>接口返回数据给服务器。</li>
<li>服务器根据模板和获取的数据拼接出最终的 HTML 字符串。</li>
<li>服务器将 HTML 字符串发送给浏览器，浏览器解析 HTML 内容并渲染。</li>
</ul>
<p>与 SSR 在服务端完成模板和数据的融合不同，CSR
是在浏览器中完成模板与数据的融合，并渲染出最终的 HTML 页面。</p>
<p><img src="https://pic.imgdb.cn/item/66d85b55d9c307b7e947679e.png"></p>
<ul>
<li>客户端向服务器或 CDN 发送请求，获取静态的 HTML
页面。注意，此时获取的 HTML 页面通常是<strong>空页面</strong>。在 HTML
页面中，会包含<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code> 和
<code>&lt;script&gt;</code> 等标签。</li>
<li>虽然 HTML 页面是空的，但浏览器仍然会解析 HTML 内容。浏览器会加载
HTML 中引用的资源，服务器或 CDN 会将相应的资源返回给浏览器，浏览器对 CSS
和 JavaScript 代码进行解释和执行。因为页面的渲染任务是由 JavaScript
来完成的，所以当 JavaScript
被解释和执行后，才会渲染出页面内容，即“白屏”结束。但初始渲染出来的内容通常是一个“骨架”，因为还没有请求
API 获取数据。</li>
<li>客户端再通过 AJAX 技术请求 API
获取数据，一旦接口返回数据，客户端就会完成动态内容的渲染，并呈现完整的页面。</li>
</ul>
<p>当用户再次通过点击“跳转”到其他页面时，浏览器并不会真正的进行跳转动作，即不会进行刷新，而是通过前端路由的方式动态地渲染页面，这对用户的交互体验会非常友好。但很明显的是，与
SSR 相比，CSR 会产生所谓的“白屏”问题。</p>
<p>同构渲染中的首次渲染与 SSR
的工作流程是一致的。当首次访问或者刷新页面时，整个页面的内容是在服务端完
成渲染的，浏览器最终得到的是渲染好的 HTML
页面。但是该页面是纯静态的，这意味着用户还不能与页面进行任何交互，因为整个应用程序的脚本还没有加载和执行。</p>
<p>同构渲染所产生的 HTML 页面与 SSR 所产生的 HTML
页面有一点最大的不同，即前者会包含当前页面所需要的初始化数据。直白地说，服务器通过
API 请求的数据会被序列化为字符串，并拼接到静态的 HTML
字符串中，最后一并发送给浏览器。这么做实际上是为了后续的激活操作。</p>
<p>假设浏览器已经接收到初次渲染的静态 HTML
页面，接下来浏览器会解析并渲染该页面。在解析过程中，浏览器会发现 HTML
代码中存在<code>&lt;link&gt;</code>和<code>&lt;script&gt;</code>标签，于是会从
CDN 或服务器获取相应的资源，这一步与 CSR 一致。当 JavaScript
资源加载完毕后，会进行激活操作，这里的激活就是我们在 Vue.js 中常说的
“hydration”。激活包含两部分工作内容。</p>
<ul>
<li>Vue.js 在当前页面已经渲染的 DOM 元素以及 Vue.js 组件所渲染的虚拟 DOM
之间建立联系。</li>
<li>Vue.js 从 HTML
页面中提取由服务端序列化后发送过来的数据，用以初始化整个 Vue.js
应用程序。</li>
</ul>
<p>激活完成后，整个应用程序已经完全被 Vue.js 接管为 CSR
应用程序了。如果刷新页面，仍然会进行服务端渲染，然后再进行激活，如此往复。</p>
<table>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">SSR</th>
<th style="text-align: center;">CSR</th>
<th style="text-align: center;">同构渲染</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">SEO</td>
<td style="text-align: center;">友好</td>
<td style="text-align: center;">不友好</td>
<td style="text-align: center;">友好</td>
</tr>
<tr>
<td style="text-align: center;">白屏问题</td>
<td style="text-align: center;">无</td>
<td style="text-align: center;">有</td>
<td style="text-align: center;">无</td>
</tr>
<tr>
<td style="text-align: center;">占用服务端资源</td>
<td style="text-align: center;">多</td>
<td style="text-align: center;">少</td>
<td style="text-align: center;">中</td>
</tr>
<tr>
<td style="text-align: center;">用户体验</td>
<td style="text-align: center;">差</td>
<td style="text-align: center;">好</td>
<td style="text-align: center;">好</td>
</tr>
</tbody>
</table>
<blockquote>
<p>同构渲染无法提升可交互时间。</p>
<p>同构渲染的“同构”一词的含义是，同样一套代码既可以在服务端运行，也可以在客户端运行。</p>
</blockquote>
<h2><span id="将虚拟-dom-渲染为-html字符串">将虚拟 DOM 渲染为 HTML
字符串</span></h2>
<p>为了将虚拟节点<code>ElementVNode</code>渲染为字符串，我们需要实现<code>renderElementVNode</code>函数。该函数接收用来描述普通标签的虚拟节点作为参数，并返回渲染后的
HTML 字符串。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderElementVNode</span>(<span class="hljs-params">vnode</span>) &#123;<br>  <span class="hljs-comment">// 取出标签名称和标签属性、子节点</span><br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">type</span>: tag , props, children &#125; = vnode<br><br>  <span class="hljs-comment">// 开始标签的头部</span><br>  <span class="hljs-keyword">let</span> ret = <span class="hljs-string">`&lt;<span class="hljs-subst">$&#123;tag&#125;</span>`</span><br>  <span class="hljs-comment">// 处理标签属性</span><br>  <span class="hljs-keyword">if</span> (props) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> props)&#123;<br>      <span class="hljs-comment">// key = &quot;value&quot;形式拼接</span><br>      ret += <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;props[key]&#125;</span>`</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 闭合开始标签</span><br>  ret += <span class="hljs-string">`&gt;`</span><br><br>  <span class="hljs-comment">// 处理子节点</span><br>  <span class="hljs-comment">// 子节点类型是字符串则是文本内容，直接拼接</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> children === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    ret += children<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(children)) &#123;<br>    <span class="hljs-comment">// 如果子节点类型是数组则递归</span><br>    children.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> &#123;<br>      ret += <span class="hljs-title function_">renderElementVNode</span>(child)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 结束标签</span><br>  ret += <span class="hljs-string">`&lt;/<span class="hljs-subst">$&#123;tag&#125;</span>&gt;`</span><br><br>  <span class="hljs-keyword">return</span> ret<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的代码存在几点缺陷：</p>
<ul>
<li><code>renderElementVNode</code>函数在渲染标签类型的虚拟节点时，还需要考虑该节点是否是自闭合标签。</li>
<li>对于属性（props）的处理会比较复杂，要考虑属性名称是否合法，还要对属性值进行
HTML 转义。</li>
<li>子节点的类型多种多样，可能是任意类型的虚拟节点，如<code>Fragment</code>、组件、函数式组件、文本等，这些都需要处理。</li>
<li>标签的文本子节点也需要进行 HTML 转义。</li>
</ul>
<p>上述这些问题都属于边界条件，接下来我们逐个处理。首先处理自闭合标签，它的术语叫作
void element：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">VOID_TAGS</span> = [<br>  <span class="hljs-string">&#x27;area&#x27;</span>,<br>  <span class="hljs-string">&#x27;base&#x27;</span>,<br>  <span class="hljs-string">&#x27;br&#x27;</span>,<br>  <span class="hljs-string">&#x27;col&#x27;</span>,<br>  <span class="hljs-string">&#x27;embed&#x27;</span>,<br>  <span class="hljs-string">&#x27;hr&#x27;</span>,<br>  <span class="hljs-string">&#x27;img&#x27;</span>,<br>  <span class="hljs-string">&#x27;input&#x27;</span>,<br>  <span class="hljs-string">&#x27;link&#x27;</span>,<br>  <span class="hljs-string">&#x27;meta&#x27;</span>,<br>  <span class="hljs-string">&#x27;param&#x27;</span>,<br>  <span class="hljs-string">&#x27;source&#x27;</span>,<br>  <span class="hljs-string">&#x27;track&#x27;</span>,<br>  <span class="hljs-string">&#x27;wbr&#x27;</span><br>]<br></code></pre></td></tr></table></figure>
<p>对于 void element，由于它无须闭合标签，所以在为此类标签生成 HTML
字符串时，无须为其生成对应的闭合标签：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 闭合开始标签，如果是 void element，则自闭合</span><br>ret += isVoidElement ? <span class="hljs-string">&#x27;/&gt;&#x27;</span> : <span class="hljs-string">&#x27;&gt;&#x27;</span><br><span class="hljs-comment">// void element没有子节点，直接返回</span><br><span class="hljs-keyword">if</span> (isVoidElement) &#123; <span class="hljs-keyword">return</span> ret &#125;<br></code></pre></td></tr></table></figure>
<p>处理属性需要考虑多个方面，首先是对 boolean attribute 的处理。所谓
boolean
attribute，并不是说这类属性的值是布尔类型，而是指，如果这类指令存在，则代表<code>true</code>，否则代表<code>false</code>。另外一点需要考虑的是安全问题，可以查看WHATWG
规范的13.1.2.3 节。</p>
<p>另外，在虚拟节点中的 props
对象中，通常会包含仅用于组件运行时逻辑的相关属性。例如，key
属性仅用于虚拟 DOM 的 Diff
算法，<code>ref</code>属性仅用于实现<code>template ref</code>的功能等。在进行服务端渲染时，应该忽略这些属性。除此之外，服务端渲染也无须考虑事件绑定。因此，也应该忽略<code>props</code>对象中的事件处理函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理Props</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">const</span> shouldIgnoreProp = [<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;ref&#x27;</span>]<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderAttrs</span>(<span class="hljs-params"><span class="hljs-attr">props</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;</span>) &#123;<br>  <span class="hljs-keyword">let</span> ret = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> props) &#123;<br>    <span class="hljs-keyword">if</span> (shouldIgnoreProp.<span class="hljs-title function_">includes</span>(key) || <span class="hljs-regexp">/^on[^a-z]/</span>.<span class="hljs-title function_">test</span>(key)) &#123;<br>      <span class="hljs-comment">// 检测属性名称，如果是事件或应该被忽略的属性，则忽略它</span><br>      <span class="hljs-keyword">continue</span><br>    &#125;<br><br>    <span class="hljs-keyword">const</span> value = props[key]<br>    <br>    ret += <span class="hljs-title function_">renderDynamicAttr</span>(key, value)<br><br>  &#125;<br>  <span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断是否是布尔属性</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">const</span> booleanAttrs = [<br>  <span class="hljs-string">&#x27;itemscope&#x27;</span>, <span class="hljs-string">&#x27;allowfullscreen&#x27;</span>, <span class="hljs-string">&#x27;formnovalidate&#x27;</span>, <span class="hljs-string">&#x27;ismap&#x27;</span>, <span class="hljs-string">&#x27;nomodule&#x27;</span>, <span class="hljs-string">&#x27;novalidate&#x27;</span>, <span class="hljs-string">&#x27;readonly&#x27;</span>,<br>  <span class="hljs-string">`async`</span>, <span class="hljs-string">`autofocus`</span>, <span class="hljs-string">`autoplay`</span>, <span class="hljs-string">`controls`</span>, <span class="hljs-string">`default`</span>, <span class="hljs-string">`defer`</span>, <span class="hljs-string">`disabled`</span>, <span class="hljs-string">`hidden`</span>,<br>  <span class="hljs-string">`loop`</span>,<span class="hljs-string">`open`</span>,<span class="hljs-string">`required`</span>,<span class="hljs-string">`reversed`</span>,<span class="hljs-string">`scoped`</span>,<span class="hljs-string">`seamless`</span>,<br>  <span class="hljs-string">`checked`</span>, <span class="hljs-string">`muted`</span>, <span class="hljs-string">`multiple`</span>, <span class="hljs-string">`selected`</span><br>]<br><span class="hljs-keyword">const</span> isBooleanAttr = (<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">boolean</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> booleanAttrs.<span class="hljs-title function_">includes</span>(key)<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 判断属性名称是否合法且安全</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">const</span> isSSRSafeAttrName = (<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">boolean</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> !<span class="hljs-regexp">/[&gt;/=&quot;&#x27;\u0009\u000a\u000c\u0020]/</span>.<span class="hljs-title function_">test</span>(key)<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理动态属性，包括布尔属性以及SSR安全</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderDynamicAttr</span>(<span class="hljs-params"><span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">value</span>: <span class="hljs-built_in">any</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isBooleanAttr</span>(key)) &#123;<br>    <span class="hljs-comment">// 对于布尔属性如果值为 false 则什么都不做</span><br>    <span class="hljs-keyword">return</span> value === <span class="hljs-literal">false</span> ? <span class="hljs-string">&#x27;&#x27;</span> : <span class="hljs-string">` <span class="hljs-subst">$&#123;key&#125;</span>`</span><br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isSSRSafeAttrName</span>(key)) &#123;<br>    <span class="hljs-comment">// 对于其他安全的属性，执行完整的渲染</span><br>    <span class="hljs-comment">// 对于属性值，我们需要对它执行 HTML 转义操作</span><br>    <span class="hljs-keyword">return</span> value === <span class="hljs-string">&#x27;&#x27;</span> ? <span class="hljs-string">` <span class="hljs-subst">$&#123;key&#125;</span>`</span><br>      : <span class="hljs-string">`<span class="hljs-subst">$&#123;key&#125;</span>=&quot;<span class="hljs-subst">$&#123;escapeHTML(value)&#125;</span>&quot;`</span><br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;class&#x27;</span> || key === <span class="hljs-string">&#x27;style&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 处理 class 和 style</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">` <span class="hljs-subst">$&#123;key&#125;</span>=<span class="hljs-subst">$&#123;normalize(value)&#125;</span>`</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 跳过不安全的属性，并打印警告信息</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<br>      <span class="hljs-string">`[server-renderer] Skipped rendering unsafe attribute name: <span class="hljs-subst">$&#123;key&#125;</span>`</span><br>    )<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于使用不同数据结构表示的 class 或
style，我们只需要将不同类型的数据结构序列化成字符串表示即可。</p>
<p>在处理属性值时，我们调用了<code>escapeHtml</code>对其进行转义处理，这对于防御
XSS 攻击至关重要。HTML 转义指的是将特殊字符转换为对应的 HTML 实体。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> escapeRE = <span class="hljs-regexp">/[&quot;&#x27;&amp;&lt;&gt;]/</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeHTML</span>(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">string</span> &#123;<br>  <span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;&#x27;</span> + value<br>  <span class="hljs-keyword">const</span> match = escapeRE.<span class="hljs-title function_">exec</span>(str)<br>  <br>  <span class="hljs-keyword">if</span> (!match) &#123;<br>    <span class="hljs-keyword">return</span> str<br>  &#125;<br>  <br>  <span class="hljs-keyword">let</span> html = <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">escaped</span>: <span class="hljs-built_in">string</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">index</span>: <span class="hljs-built_in">number</span><br>  <span class="hljs-keyword">let</span> lastIndex = <span class="hljs-number">0</span><br>  <br>  <span class="hljs-keyword">for</span> (index = match.<span class="hljs-property">index</span> ; index &lt; str.<span class="hljs-property">length</span>; index++) &#123;<br>    <span class="hljs-keyword">switch</span> (str.<span class="hljs-title function_">charCodeAt</span>(index)) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">34</span>: <span class="hljs-comment">// &quot;</span><br>        escaped = <span class="hljs-string">&#x27;&amp;quot&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <br>      <span class="hljs-keyword">case</span> <span class="hljs-number">38</span>: <span class="hljs-comment">// &amp;</span><br>        escaped = <span class="hljs-string">&#x27;&amp;amp&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <br>      <span class="hljs-keyword">case</span> <span class="hljs-number">39</span>: <span class="hljs-comment">// &#x27;</span><br>        escaped = <span class="hljs-string">&#x27;&amp;#39&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <br>      <span class="hljs-keyword">case</span> <span class="hljs-number">60</span>: <span class="hljs-comment">// &lt;</span><br>        escaped = <span class="hljs-string">&#x27;&amp;lt&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <br>      <span class="hljs-keyword">case</span> <span class="hljs-number">62</span>: <span class="hljs-comment">// &gt;</span><br>        escaped = <span class="hljs-string">&#x27;&amp;gt&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">continue</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (lastIndex !== index) &#123;<br>      html += str.<span class="hljs-title function_">substring</span>(lastIndex++, index)<br>    &#125;<br>    <br>    html += escaped<br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> lastIndex !== index ? html : str.<span class="hljs-title function_">substring</span>(lastIndex, index)<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2><span id="将组件渲染为-html-字符串">将组件渲染为 HTML 字符串</span></h2>
<p>实际上，把组件渲染为 HTML 字符串与把普通标签节点渲染为 HTML
字符串并没有本质区别。由于组件要渲染的内容可能是任意类型的节点，我们需要封装一个通用渲染函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderVNode</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = <span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">type</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">renderElementVNode</span>(vnode)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">renderComponentVNode</span>(vnode)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">type</span> === <span class="hljs-title class_">Text</span>) &#123;<br>    <span class="hljs-comment">// 处理文本</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">type</span> === <span class="hljs-title class_">Fragment</span>) &#123;<br>    <span class="hljs-comment">// 处理片段</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>	...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>下面是客户端渲染的初始流程：</p>
<p><img src="https://pic.imgdb.cn/item/66d8774bd9c307b7e96ce290.png"></p>
<p>在进行服务端渲染时，组件的初始化流程与客户端渲染时组件的初始化流程基本一致，但有两个重要的区别。</p>
<ul>
<li>服务端渲染的是应用的当前快照，它不存在数据变更后重新渲染的情况。因此，所有数据在服务端都无须是响应式的。利用这一点，我们可以减少服务端渲染过程中创建响应式数据对象的开销。</li>
<li>服务端渲染只需要获取组件要渲染的<code>subTree</code>即可，无须调用渲染器完成真实
DOM 的创建。因此，在服务端渲染时，可以忽略“设置 render effect
完成渲染”这一步。</li>
</ul>
<p>服务端渲染初始化组件：</p>
<p><img src="https://pic.imgdb.cn/item/66d87824d9c307b7e96db6c7.png"></p>
<p>只需要对客户端初始化组件的逻辑稍作调整，即可实现组件在服务端的渲染。另外，由于组件在服务端渲染时，不需要渲染真实
DOM 元素，所以无须创建并执行 render
effect。这意味着，组件的<code>beforeMount</code>以及<code>mounted</code>钩子不会被触发。而且，由于服务端渲染不存在数据变更后的重新渲染逻辑，所以<code>beforeUpdate</code>和<code>updated</code>钩子也不会在服务端执行。</p>
<blockquote>
<p>当组件的代码在服务端运行时，由于不会对组件进行真正的挂载操作，即不会把虚拟
DOM 渲染为真实 DOM
元素，所以组件的<code>beforeMount</code>与<code>mounted</code>这两个钩子函数不会执行。又因为服务端渲染的是应用的快照，所以不存在数据变化后的重新渲染，因此，组件的<code>beforeUpdate</code>与<code>updated</code>这两个钩子函数也不会执行。另外，在服务端渲染时，也不会发生组件被卸载的情况，所以组件的<code>beforeUnmount</code>与<code>unmounted</code>这两个钩子函数也不会执行。实际上，只有<code>beforeCreate</code>与<code>created</code>这两个钩子函数会在服务端执行，所以当你编写组件代码时需要额外注意。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">renderComponentVNode</span>(<span class="hljs-params"><span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span></span>) &#123;<br>  <span class="hljs-comment">// 检查是否是函数式组件</span><br>  <span class="hljs-keyword">const</span> isFunctional = <span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">type</span> === <span class="hljs-string">&#x27;function&#x27;</span><br><br>  <span class="hljs-comment">// 获取组件</span><br>  <span class="hljs-keyword">let</span> componentOptions = vnode.<span class="hljs-property">type</span> <span class="hljs-keyword">as</span> componentOptions<br>  <span class="hljs-comment">// 如果是函数式组件，则将compVNode.type作为渲染函数</span><br>  <span class="hljs-comment">// 将compVNode.type.props作为props选项</span><br>  <span class="hljs-keyword">if</span> (isFunctional) &#123;<br>    componentOptions.<span class="hljs-property">render</span> = vnode.<span class="hljs-property">type</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">FuncComponent</span><br>    componentOptions.<span class="hljs-property">props</span> = (vnode.<span class="hljs-property">type</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">FuncComponent</span>).<span class="hljs-property">props</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;<br>  &#125;<br><br>  <span class="hljs-comment">// 获取组件渲染函数与props定义</span><br>  <span class="hljs-keyword">let</span> &#123; render, data, setup, <span class="hljs-attr">props</span>: propsOption, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated &#125; = componentOptions<br><br>  <span class="hljs-comment">// 创建实例前钩子</span><br>  beforeCreate &amp;&amp; <span class="hljs-title function_">beforeCreate</span>()<br><br>  <span class="hljs-comment">// 无须使用 reactive() 创建 data 的响应式版本</span><br>  <span class="hljs-keyword">const</span> state = data ? <span class="hljs-title function_">data</span>() : <span class="hljs-literal">undefined</span><br>  <span class="hljs-keyword">const</span> [props, attrs] = <span class="hljs-title function_">resolveProps</span>(propsOption, vnode.<span class="hljs-property">props</span>)<br><br>  <span class="hljs-keyword">const</span> slots = vnode.<span class="hljs-property">children</span> || &#123;&#125;<br><br>  <span class="hljs-comment">// 创建实例</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">ComponentInstance</span> = &#123;<br>    <span class="hljs-comment">// 状态数据data</span><br>    state,<br>    <span class="hljs-comment">// 这里 props 无须 shallowReactive</span><br>    props,<br>    <span class="hljs-comment">// 是否挂载</span><br>    <span class="hljs-attr">isMounted</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-comment">// 渲染内容subTree</span><br>    <span class="hljs-attr">subTree</span>: <span class="hljs-literal">null</span>,<br>    <span class="hljs-comment">// 插槽</span><br>    <span class="hljs-attr">slots</span>: slots,<br>    <span class="hljs-comment">// 生命周期函数</span><br>    <span class="hljs-attr">mounted</span>: [],<br>    <span class="hljs-attr">unmounted</span>: [],<br><br>    <span class="hljs-comment">// keepAlive</span><br>    <span class="hljs-attr">keepAliveCtx</span>: <span class="hljs-literal">undefined</span><br>  &#125;<br>  <br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-built_in">string</span>, ...<span class="hljs-attr">payload</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-keyword">const</span> eventName =<span class="hljs-string">`on<span class="hljs-subst">$&#123;event[<span class="hljs-number">0</span>].toUpperCase() + event.slice(<span class="hljs-number">1</span>)&#125;</span>`</span><br>    <span class="hljs-comment">// 根据处理后的事件名去寻找对用的事件处理函数</span><br>    <span class="hljs-keyword">const</span> handler = instance.<span class="hljs-property">props</span>[eventName]<br>    <span class="hljs-keyword">if</span> (handler) &#123;<br>      <span class="hljs-title function_">handler</span>(...payload)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">`[<span class="hljs-subst">$&#123;eventName&#125;</span>] <span class="hljs-subst">$&#123;eventName&#125;</span> does not exist`</span>)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// setupContext</span><br>  <span class="hljs-keyword">const</span> setupContext = &#123; attrs, emit, slots &#125;<br>  <span class="hljs-comment">// setupState用于存储由setup返回的数据</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">setupState</span>: <span class="hljs-built_in">any</span> | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br><br>  <span class="hljs-comment">// 在调用setup函数前设置当前组件实例</span><br>  <span class="hljs-title function_">setCurrentInstance</span>(instance)<br>  <span class="hljs-comment">// 处理setup相关</span><br>  <span class="hljs-keyword">if</span> (setup) &#123;<br>    <span class="hljs-comment">// 调用setup函数</span><br>    <span class="hljs-comment">// 将只读版本的 props 作为第一个参数传递，避免用户意外地修改 props 的值</span><br>    <span class="hljs-comment">// 将setupContext作为第二个参数</span><br>    <span class="hljs-keyword">const</span> setupResult = <span class="hljs-title function_">setup</span>(<span class="hljs-title function_">shallowReadonly</span>(instance.<span class="hljs-property">props</span>), setupContext)<br>    <span class="hljs-comment">// setup返回函数，将其作为渲染函数</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setupResult === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>      <span class="hljs-keyword">if</span> (render) &#123;<br>        <span class="hljs-comment">// 如果存在渲染函数，则报告冲突错误</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;render conflicts&#x27;</span>)<br>        <span class="hljs-comment">// 将setupResult作为渲染函数</span><br>        render = setupResult<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则作为数据状态赋值给setupState</span><br>        setupState = setupResult<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 执行完成后重置currentInstance</span><br>    <span class="hljs-title function_">setCurrentInstance</span>(<span class="hljs-literal">null</span>)<br>  &#125;<br><br>  <span class="hljs-comment">// 将组件实例设置到vnode上，用于后续更新</span><br>  vnode.<span class="hljs-property">component</span> = instance<br><br>  <span class="hljs-comment">// 创建渲染上下文对象，本质是组件实例的代理</span><br>  <span class="hljs-keyword">const</span> renderContext = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(instance, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; state, props, slots &#125; = target<br><br>      <span class="hljs-comment">// 如果key值为$slots，直接返回对应插槽</span><br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&quot;$slots&quot;</span>) <span class="hljs-keyword">return</span> slots<br><br>      <span class="hljs-comment">// 先尝试读取自身状态数据</span><br>      <span class="hljs-keyword">if</span> (state &amp;&amp; key <span class="hljs-keyword">in</span> state) &#123;<br>        <span class="hljs-keyword">return</span> state[key]<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> props) &#123;<br>        <span class="hljs-keyword">return</span> props[key]<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;state does not exist&#x27;</span>)<br>      &#125;<br>    &#125;,<br>    <span class="hljs-title function_">set</span> (target, key, value) &#123;<br>      <span class="hljs-keyword">const</span> &#123; state, props &#125; = target<br>      <span class="hljs-keyword">if</span> (state &amp;&amp; key <span class="hljs-keyword">in</span> state) &#123;<br>        state[key] = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> props) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`Attempting to mutate prop &quot;<span class="hljs-subst">$&#123;<span class="hljs-built_in">String</span>(key)&#125;</span>&quot;. Props are readonly.`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (setupState &amp;&amp; key <span class="hljs-keyword">in</span> setupState) &#123;<br>        <span class="hljs-comment">// setupState处理</span><br>        setupState[key] = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;state does not exist&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-comment">// 完成创建钩子</span><br>  created &amp;&amp; created.<span class="hljs-title function_">call</span>(renderContext)<br>  <br>  <span class="hljs-keyword">const</span> subTree = render?.<span class="hljs-title function_">call</span>(renderContext, renderContext)<br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">renderVNode</span>(subTree)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该实现与客户端渲染的逻辑基本一致。</p>
<h2><span id="客户端激活的原理">客户端激活的原理</span></h2>
<p>当组件的代码在客户端执行时，不会再次创建 DOM 。</p>
<p>由于浏览器在渲染了由服务端发送过来的 HTML
字符串之后，页面中已经存在对应的 DOM
元素了，所以组件代码在客户端运行时，不需要再次创建相应的 DOM
元素。但是，组件代码在客户端运行时，仍然需要做两件重要的事：</p>
<ul>
<li>在页面中的 DOM 元素与虚拟节点对象之间建立联系；</li>
<li>为页面中的 DOM 元素添加事件绑定。</li>
</ul>
<p>对于同构渲染，为了应用程序在后续更新过程中能够正确运行，我们需要在页面中已经存在的
DOM
对象与虚拟节点对象之间建立正确的联系。在服务端渲染的过程中，会忽略虚拟节点中与事件相关的
props。所以，当组件代码在客户端运行时，我们需要将这些事件正确地绑定到元素上。其实，这两个步骤就体现了客户端激活的含义。</p>
<p>对于同构应用，我们将使用独立的<code>renderer.hydrate</code>函数来完成激活。我们先实现<code>hydrateNode</code>，该函数作为激活的总入口：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hydrateNode</span>(<span class="hljs-params"><span class="hljs-attr">node</span>: <span class="hljs-title class_">Node</span> | <span class="hljs-literal">null</span>, <span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span>, <span class="hljs-attr">container</span>: <span class="hljs-title class_">Container</span></span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">type</span> &#125; = vnode<br><br>  <span class="hljs-comment">// vnode.el 引用真实 DOM</span><br>  vnode.<span class="hljs-property">el</span> = node <span class="hljs-keyword">as</span> <span class="hljs-title class_">Container</span><br><br>  <span class="hljs-comment">// 检查虚拟 DOM 的类型，如果是组件，则调用 mountComponent 函数完成激活</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-title function_">mountComponent</span>(vnode, container, <span class="hljs-literal">null</span>)<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">type</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 检查真实 DOM 的类型与虚拟 DOM 的类型是否匹配</span><br>    <span class="hljs-keyword">if</span> (node?.<span class="hljs-property">nodeType</span> !== <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;mismatch&#x27;</span>, node, vnode)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 普通元素则调用hydrateElement</span><br>      <span class="hljs-title function_">hydrateElement</span>(node <span class="hljs-keyword">as</span> <span class="hljs-title class_">Container</span>, vnode)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 重要：hydrateNode 函数需要返回当前节点的下一个兄弟节点，以便继续进行后续的激活操作</span><br>  <span class="hljs-keyword">return</span> (node <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span>).<span class="hljs-property">nextSibling</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于组件类型节点的激活操作，则可以直接通过<code>mountComponent</code>函数来完成。对于普通元素的激活操作，则可以通过<code>hydrateElement</code>函数来完成。最后，<code>hydrateNode</code>函数需要返回当前激活节点的下一个兄弟节点，以便进行后续的激活操作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hydrateElement</span>(<span class="hljs-params"><span class="hljs-attr">el</span>: <span class="hljs-title class_">Container</span>, <span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span></span>) &#123;<br>  <span class="hljs-keyword">if</span> (vnode.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) &#123;<br>      <span class="hljs-comment">// 只有事件类型的 props 需要处理</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^on/</span>.<span class="hljs-title function_">test</span>(key)) &#123;<br>        <span class="hljs-title function_">patchProps</span>(el, key, <span class="hljs-literal">null</span>, vnode.<span class="hljs-property">props</span>[key])<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 递归激活子节点</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(vnode.<span class="hljs-property">children</span>)) &#123;<br>    <span class="hljs-keyword">let</span> nextNode = el.<span class="hljs-property">firstChild</span><br>    <span class="hljs-keyword">const</span> len = vnode.<span class="hljs-property">children</span>.<span class="hljs-property">length</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; len; i++) &#123;<br>      <span class="hljs-comment">// 每当激活一个子节点，hydrateNode 函数都会返回当前子节点的下一个兄弟节点</span><br>      nextNode = <span class="hljs-title function_">hydrateNode</span>(nextNode, vnode.<span class="hljs-property">children</span>[i], el)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于组件的激活，我们还需要针对性地处理<code>mountComponent</code>函数。由于服务端渲染的页面中已经存在真实
DOM
元素，所以当调用<code>mountComponent</code>函数进行组件的挂载时，无须再次创建真实
DOM 元素。我们调整<code>mountComponent</code>函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript">instance.<span class="hljs-property">update</span> = <span class="hljs-title function_">watchEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <br>	...<br>    <br>    <span class="hljs-keyword">if</span> (!instance.<span class="hljs-property">isMounted</span>) &#123;<br><br>      <span class="hljs-comment">// 挂载前钩子</span><br>      beforeMount &amp;&amp; <span class="hljs-title function_">beforeMount</span>().<span class="hljs-title function_">call</span>(state)<br>      <span class="hljs-comment">// 如果 vnode.el 存在，则意味着要执行激活</span><br>      <span class="hljs-keyword">if</span> (compVNode.<span class="hljs-property">el</span>) &#123;<br>        <span class="hljs-title function_">hydrateNode</span>(compVNode.<span class="hljs-property">el</span>, subTree, container)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 初次挂载组件subTree</span><br>        <span class="hljs-title function_">patch</span>(<span class="hljs-literal">undefined</span>, subTree, container, anchor)<br>      &#125;<br>      <br>      <span class="hljs-comment">// 将组件实例的 isMounted 设置为 true，这样当更新发生时就不会再次进行挂载操作</span><br>      instance.<span class="hljs-property">isMounted</span> = <span class="hljs-literal">true</span><br>      instance.<span class="hljs-property">renderContext</span> = renderContext<br><br>      <span class="hljs-comment">// 完成挂载钩子</span><br>      mounted &amp;&amp; mounted.<span class="hljs-title function_">call</span>(state)<br>      <span class="hljs-comment">// 遍历mounted生命周期函数数组执行生命周期函数</span><br>      instance.<span class="hljs-property">mounted</span> &amp;&amp; instance.<span class="hljs-property">mounted</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">hook</span> =&gt;</span> hook.<span class="hljs-title function_">call</span>(renderContext))<br>      <span class="hljs-comment">// instance.unmounted &amp;&amp; instance.unmounted.forEach(hook =&gt; hook.call(renderContext))</span><br><br>    &#125; <br>    <br>    ...<br><br>  &#125;, &#123;<br>    <span class="hljs-attr">scheduler</span>: queueJob<br>&#125;)<br></code></pre></td></tr></table></figure>
<h2><span id="编写同构的代码">编写同构的代码</span></h2>
<p>“同构”一词指的是一份代码既在服务端运行，又在客户端运行。因此，在编写组件代码时，应该额外注意因代码运行环境的不同所导致的差异。</p>
<h3><span id="组件的生命周期">组件的生命周期</span></h3>
<p>在前面的内容中我们已经知道只有<code>beforeCreate</code>与<code>created</code>这两个钩子函数会在服务端执行。所以我们在<code>created</code>钩子函数中设置定时器对于服务端渲染没有任何意义。这是因为服务端渲染的是应用程序的快照，所谓快照，指的是在当前数据状态下页面应该呈现的内容。所以，在定时器到时，修改数据状态之前，应用程序的快照已经渲染完毕了。所以我们说，在服务端渲染时，定时器内的代码没有任何意义。遇到这类问题时，我们通常有两个解决方案：</p>
<ul>
<li>方案一：将创建定时器的代码移动到 mounted
钩子中，即只在客户端执行定时器；</li>
<li>方案二：使用环境变量包裹这段代码，让其不在服务端运行。
<ul>
<li>在通过<code>webpack</code>或<code>Vite</code>等构建工具搭建的同构项目中，通常带有这种环境变量。</li>
</ul></li>
</ul>
<h3><span id="使用跨平台的-api">使用跨平台的 API</span></h3>
<p>由于组件的代码既运行于浏览器，又运行于服务器，所以在编写代码的时候要避免使用平台特有的
API。例如，仅在浏览器环境中才存在的<code>window.document</code>等对象。然而，有时你不得不使用这些平台特有的
API。这时你可以使用诸如<code>import.meta.env.SSR</code>这样的环境变量来做代码守卫。类似地，Node.js
中特有的 API
也无法在浏览器中运行。因此，为了减轻开发时的心智负担，我们可以选择跨平台的第三方库。例如，使用
Axios 作为网络请求库。</p>
<h3><span id="只在某一端引入模块">只在某一端引入模块</span></h3>
<p>我们自己编写的组件的代码是可控的，这时我们可以使用跨平台的 API
来保证代码“同构”。然而，第三方模块的代码非常不可控。如果模块中存在非同构的代码，则仍然会发生错误。对于这个问题，有两种解决方案，方案一是使用<code>import.meta.env.SSR</code>等来做代码守卫，这样做虽然能解决问题，但是在大多数情况下我们无法修改第三方模块的代码。因此，更多时候我们会采用方案二来解决问题，即条件引入：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">let</span> storage</span><br><span class="language-javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">SSR</span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// CSR</span></span><br><span class="language-javascript">    storage = <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./storage.js&#x27;</span>)</span><br><span class="language-javascript">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// SSR</span></span><br><span class="language-javascript">    storage = <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./server-storage.js&#x27;</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h3><span id="避免交叉请求引起的状态污染">避免交叉请求引起的状态污染</span></h3>
<p>在服务端渲染时，我们会为每一个请求创建一个全新的应用实例，这是为了避免不同请求共用同一个应用实例所导致的状态污染。</p>
<p>除了要为每一个请求创建独立的应用实例之外，状态污染的情况还可能发生在单个组件的代码中。因为服务器与用
户是一对多的关系，在编写组件代码时，要额外注意组件中出现的全局变量，很容易因为用户请求相互影响造成请求间的交叉污染。</p>
<h3><span id="ltclientonlygt组件"><code>&lt;ClientOnly&gt;</code>组件</span></h3>
<p>我们可以自行实现一个<code>&lt;ClientOnly&gt;</code>的组件，该组件可以让模板的一部分内容仅在客户端渲染。用
<code>&lt;ClientOnly&gt;</code> 组件包裹了不兼容 SSR
的组件，这样，在服务端渲染时就会忽略该组件，且该组件仅会在客户端被渲染。</p>
<p><code>&lt;ClientOnly&gt;</code>利用了 CSR 与 SSR
的差异，原理是利用了<code>onMounted</code>钩子只会在客户端执行的特性：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">ClientOnly</span> = &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"><span class="hljs-attr">props</span>: <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">symbol</span> | <span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;, &#123; slots &#125;</span>) &#123;<br>    <span class="hljs-comment">// 标记变量，仅在客户端渲染时为 true</span><br>    <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br>    <span class="hljs-comment">// onMounted钩子只在客户端执行</span><br>    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      show.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>    &#125;)<br>    <br>    <span class="hljs-comment">// 服务端什么都不做</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> (show.<span class="hljs-property">value</span> &amp;&amp; slots.<span class="hljs-property">default</span> ? slots.<span class="hljs-title function_">default</span>() : <span class="hljs-literal">null</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>&lt;ClientOnly&gt;</code>组件并不会导致客户端激活失败。因为在客户端激活的时候，<code>mounted</code>钩子还没有触发，所以服务端与客户端渲染的内容一致，即什么都不渲染。等到激活完成，且<code>mounted</code>钩子触发执行之后，才会在客户端将<code>&lt;ClientOnly&gt;</code>组件的插槽内容渲染出来。</p>
<h1><span id="总结">总结</span></h1>
<p>我们首先讨论了 CSR、SSR
和同构渲染的工作机制，以及它们各自的优缺点：</p>
<div class="line-block">     SSR | CSR | 同构渲染 |<br>
:————: | :–: | :——: | :: |<br>
     SEO | 友好 | 不友好 | 友好 |<br>
   白屏问题 | 无 | 有 | 无 |<br>
占用服务端资源 | 多 | 少 | 中 |<br>
   用户体验 | 差 | 好 | 好 |</div>
<p>接着，我们讨论了如何把虚拟节点渲染为字符串，以及如何将组件渲染为 HTML
字符串。在服务端渲染组件与渲染普通标签并没有本质区别。我们只需要通过执行组件的<code>render</code>函数，得到该组件所渲染的<code>subTree</code>并将其渲染为
HTML 字符串即可。</p>
<p>之后，我们讨论了客户端激活的原理。在同构渲染过程中，组件的代码会分别在服务端和浏览器中执行一次。在服务端，组件会被渲染为静态的
HTML 字符串，并发送给浏览器。浏览器则会渲染由服务端返回的静态的 HTML
内容，并下载打包在静态资源中的组件代码。当下载完毕后，浏览器会解释并执行该组件代码。当组件代码在客户端执行时，由于页面中已经存在对应的
DOM 元素，所以渲染器并不会执行创建 DOM
元素的逻辑，而是会执行激活操作。对于编写同构的组件代码，组件代码既运行于服务端，也运行于客户端，所以当我们编写组件代码时要额外注意。</p>
<p>至此，我们分别实现了响应式，渲染器，编译器以及同构渲染部分的功能，内容较为分散，并不是一个完整的MVVM框架系统。我们将整合目前实现的基础功能，真正实现一个简单的MVVM。</p>

	</article>

	 
    <div class="kira-post-copyright">
        <strong>Author：</strong>破酥 | C4iN<br>
        <strong>Link：</strong><a href="https://c4in1.github.io/2024/09/04/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM-5/" title="https:&#x2F;&#x2F;c4in1.github.io&#x2F;2024&#x2F;09&#x2F;04&#x2F;MVVM&#x2F;实现一个简单的MVVM-5&#x2F;" target="_blank" rel="noopener">https:&#x2F;&#x2F;c4in1.github.io&#x2F;2024&#x2F;09&#x2F;04&#x2F;MVVM&#x2F;实现一个简单的MVVM-5&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可
        
    </div>

  
	<div class="kira-post-nav">
		<nav class="post-nav">
			  
			<!-- 先找到与当前文字相同的目录 -->
			                  
			<!-- 在找到当前文章所在的 index -->
			                    
			<!-- 上一篇文章 -->
			<div class="old">
				<span>上一章</span>
				<a href="/2024/08/30/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM-4/"> 实现一个简单的MVVM-4</a>
			</div>
			       
			<!-- 下一篇文章 -->
			<div class="new">
				<span>下一章</span>
				<a href="/2024/09/05/MVVM/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84MVVM-6/"> 实现一个简单的MVVM-6</a>
			</div>
			                                      
		</nav>
	</div>
	
	<div class="kira-post-meta kira-rainbow">
		
			<a class="kirafont icon-container-fill -link" href="/categories/MVVM/">MVVM</a>
		
		
			<a class="kirafont icon-tag-fill -none-link" href="/tags/MVVM/" rel="tag">MVVM</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/Vue/" rel="tag">Vue</a> <a class="kirafont icon-tag-fill -none-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>
		
	</div>
	
	<div class="kira-post-footer">
		

		
	<div class="giscus"></div>
  
    <script src="https://giscus.app/client.js"
      data-repo="C4in1/BlogGitTalk"
      data-repo-id="R_kgDOMgx61Q"
      data-category="General"
      data-category-id="DIC_kwDOMgx61c4Chec4"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="top"
      data-theme="light"
      data-lang="en"
      data-loading="lazy"
      crossorigin="anonymous"
      async  
    ></script>
  

	</div>
	
</div>

				</div>
			</div>
			<div class="kira-right-column">
	<a onclick="document.querySelector('#kira-top-header').scrollIntoView({behavior: 'smooth'});" class="kira-backtotop" aria-label="回到顶部" title="回到顶部">
		<button class="mdui-fab mdui-ripple">
			<i class="kirafont icon-caret-up"></i>
		</button>
	</a>
</div>

		</div>
	</body>
</html>
